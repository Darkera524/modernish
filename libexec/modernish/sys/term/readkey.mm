#! /module/for/moderni/sh

# readkey: read a single character from the keyboard without echoing back to
# the terminal. Buffering is done so that multiple waiting characters are
# read one at a time.
#
# Usage: readkey [ -t TIMEOUT ] [ -r ] VARNAME
#
# -t: Specify a TIMEOUT in seconds (one significant digit after the
#     decimal point). After the timeout expires, no character is read and
#     readkey returns status 1.
#	http://pubs.opengroup.org/onlinepubs/9699919799/utilities/stty.html#tag_20_123_05_05
#	http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap11.html#tag_11_01_07_03
#
# -r: Raw mode. Disables Ctrl+C and Ctrl+Z processing as well as
#     translation of carriage return (13) to linefeed (10).
#
# The character read is stored into the variable referenced by VARNAME,
# which defaults to `REPLY` if not specified.
#
# Exit status:
# 0: A character was read successfully.
# 1: There were no characters to read (timeout).
# 2: Standard input is not on a terminal.
#
# --- begin license ---
# Copyright (c) 2017 Martijn Dekker <martijn@inlv.org>, Groningen, Netherlands
#
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
#
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# --- end license ---

unset -v _Msh_rK_buf
readkey() {
	# ____ begin option parser ____
	# This parser was generated by: generateoptionparser -o -f readkey -v _Msh_rKo_ -n r -a t
	unset -v _Msh_rKo_r _Msh_rKo_t
	forever do
		case ${1-} in
		( -[!-]?* ) # split a set of combined options
			_Msh_rKo__o=${1#-}
			shift
			forever do
				case ${_Msh_rKo__o} in
				( '' )	break ;;
				# if the option requires an argument, split it and break out of loop
				# (it is always the last in a combined set)
				( [t]* )
					_Msh_rKo__a=-${_Msh_rKo__o%"${_Msh_rKo__o#?}"}
					push _Msh_rKo__a
					_Msh_rKo__o=${_Msh_rKo__o#?}
					if not empty "${_Msh_rKo__o}"; then
						_Msh_rKo__a=${_Msh_rKo__o}
						push _Msh_rKo__a
					fi
					break ;;
				esac
				# split options that do not require arguments (and invalid options) until we run out
				_Msh_rKo__a=-${_Msh_rKo__o%"${_Msh_rKo__o#?}"}
				push _Msh_rKo__a
				_Msh_rKo__o=${_Msh_rKo__o#?}
			done
			while pop _Msh_rKo__a; do
				set -- "${_Msh_rKo__a}" "$@"
			done
			unset -v _Msh_rKo__o _Msh_rKo__a
			continue ;;
		( -[r] )
			eval "_Msh_rKo_${1#-}=''" ;;
		( -[t] )
			let "$# > 1" || die "readkey: $1: option requires argument" || return
			eval "_Msh_rKo_${1#-}=\$2"
			shift ;;
		( -- )	shift; break ;;
		( -* )	die "readkey: invalid option: $1" || return ;;
		( * )	break ;;
		esac
		shift
	done
	# ^^^^ end option parser ^^^^

	# timeout: convert seconds to tenths of seconds
	if isset _Msh_rKo_t; then
		case ${_Msh_rKo_t} in
		( '' | *[!0123456789.]* | *. | *.*.* )
			die "readkey: -t: invalid timeout value: ${_Msh_rKo_t}" || return ;;
		( *.* )
			# have just 1 digit after decimal point, then remove the point
			match "${_Msh_rKo_t}" "*.??*" && _Msh_rKo_t=${_Msh_rKo_t%${_Msh_rKo_t##*.?}}
			_Msh_rKo_t=${_Msh_rKo_t%.?}${_Msh_rKo_t##*.} ;;
		( * )
			_Msh_rKo_t=${_Msh_rKo_t}0 ;;
		esac
	fi

	case $# in
	( 0 )	set REPLY ;;
	( 1 )	isvarname "$1" || die "readkey: invalid variable name: $1" || return ;;
	( * )	die "readkey: excess arguments (expected 1)" || return ;;
	esac

	# If the buffer variable is empty, fill it with up to 512 bytes from the keyboard buffer.
	# (note: QRK_EXECFNBI workaround [unset -f before exec in subshell] occurs several times below)
	case ${_Msh_rK_buf-} in
	( '' )	is onterminal 0 || return 2
		unset -v _Msh_rK_err
		_Msh_rK_s=$(unset -f stty; PATH=$DEFPATH exec stty -g) || die "readkey: save terminal state: stty failed" || return
		pushtrap '_Msh_readkey_setTerminalState' SIGCONT
		_Msh_readkey_setTerminalState
		forever do
			_Msh_rK_buf=$(PATH=$DEFPATH command dd count=1 2>/dev/null && put X) && break
			let "$? > 125" && _Msh_rK_err=1 && break
		done
		poptrap SIGCONT
		PATH=$DEFPATH command stty "${_Msh_rK_s}" || die "readkey: restore terminal state: stty failed"
		unset -v _Msh_rK_s
		if isset _Msh_rK_err; then die "readkey: 'dd' failed" || return; fi
		_Msh_rK_buf=${_Msh_rK_buf%X}	# defeat stripping of final linefeeds by cmd subst
		not empty "${_Msh_rK_buf}" || return 1 ;;
	esac

	# Return just one character at a time from the buffer variable.
	if thisshellhas BUG_MULTIBYTE && match "${_Msh_rK_buf}" "[!$ASCIICHARS]*"; then
		# This shell can't parse multibyte UTF-8 characters, so fall back on 'sed' to identify the first character.
		_Msh_rK_temp=$(unset -f sed
			putln "${_Msh_rK_buf}X" | PATH=$DEFPATH exec sed '1 s/.//; ')
		_Msh_rK_temp=${_Msh_rK_temp%X}
		eval "$1=\${_Msh_rK_buf%\"\${_Msh_rK_temp}\"}
			_Msh_rK_buf=\${_Msh_rK_buf#\"\${$1}\"}"
	else
		# We can use nice and fast parameter substitutions.
		eval "$1=\${_Msh_rK_buf%\"\${_Msh_rK_buf#?}\"}"
		_Msh_rK_buf=${_Msh_rK_buf#?}
	fi
}

_Msh_readkey_setTerminalState() {
	set -- -icanon -echo -echonl -istrip -ixon -ixoff -iexten
	isset _Msh_rKo_r && set -- "$@" -isig nl
	isset _Msh_rKo_t && set -- "$@" min 0 time "${_Msh_rKo_t}"
	PATH=$DEFPATH command stty "$@" || die "readkey: set terminal state: stty failed"
}

if thisshellhas ROFUNC; then
	readonly -f readkey _Msh_readkey_setTerminalState
fi
