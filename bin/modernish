#! /bin/sh
# -*- mode: sh; -*-

# modernish - an attempt at a cross-platform POSIX shell modernizer library.
# Inspired by modernizr (feature testing) and jQuery (extending the language),
#
# POSIX reference: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html
#
# --- begin license ---
# Copyright (c) 2016 Martijn Dekker <martijn@inlv.org>, Groningen, Netherlands
# 
# Permission to use, copy, modify, and/or distribute this software for any
# purpose with or without fee is hereby granted, provided that the above
# copyright notice and this permission notice appear in all copies.
# 
# THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
# WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
# MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
# ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
# WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
# ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
# OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
# --- end license ---
#
# modernish system constants (read-only variables):
#	$MSH_VERSION		version of modernish
#	$MSH_CAP		space-separated ID list of shell capabilities and bugs
#	$MSH_SHELL		default shell for this modernish installation (e.g. /bin/sh)
#	$MSH_PREFIX		installation prefix for this modernish installation (e.g. /usr/local)
#	$ME			replacement for $0 (for hashbang path #!/usr/bin/env modernish)
#	$UID			the invoking user's UID
#	$USER			the invoking user's username
#	$CC?			control characters $CCn, etc. (same as printf \n, etc.)
#	$CC??			control characters $CC01 .. $CC1F
#	$CONTROLCHARS		all control characters
#	$WHITESPACE		all whitespace characters
#	$ASCIIALNUM		all alphanumeric characters in ASCII
#	$SHELLSAFECHARS		portable characters that don't need to be shell-quoted
# modernish internal global variables and functions namespace:
#	_Msh_*

# TODO:
# - trawl for ideas and functionality:
#	http://www.etalabs.net/sh_tricks.html
#	https://github.com/stephane-chazelas/misc-scripts
#	https://github.com/spencertipping/bash-lambda
# - figure out a reliable way to determine the full path of the shell
#   that is executing modernish
#	> Linux: readlink /proc/$$/exe
#	> ... other systems?
# - for systems that succeed in the above, keep cache of test battery
#   results ($MSH_CAP) in /tmp/_Msh_cache_$UID/MSH_CAP, discarding it
#   if the cache is older than the shell

# -------------

case ${MSH_VERSION+s} in
( s )	if ! { (unset -v MSH_VERSION) 2>/dev/null && unset -v MSH_VERSION; }; then
		case ${1:-} in
		( --version )
			printf '%s\n' "$MSH_VERSION"
			return 0 ;;
		( * )
			printf '%s\n' 'Modernish is already initialized. To reload it, exit this shell first.' 1>&2
			return 1 || exit 1 ;;
		esac
	fi ;;
esac

# Remove all aliases from the execution environment, as some shells set
# unhelpful default aliases. (Particularly, AT&T ksh sets
#	alias command="command "
# which defeats the ability of 'command' to bypass aliases, which would break
# feature testing using the "thisshellhas" function). In user profiles, any
# wanted aliases can be set after sourcing modernish; the modernish functions
# will already have been parsed so new aliases won't have an effect on them.
\unalias -a 2>| /dev/null \
|| case ${ZSH_VERSION+s} in
( s )	\unalias -m '*' ;;
esac

# Request standards compliance.

# ... zsh:
case ${ZSH_VERSION+z} in
( z )	emulate sh
	setopt POSIX_ARGZERO MULTIBYTE 2>/dev/null
	# zsh has the unique ability to disable reserved words, so disable
	# certain zsh-specific reserved words on non-interactive shells so
	# that modernish scripts can use the names for functions.
	# Keep 'coproc', 'export', 'function', 'select', 'time' and 'typeset'
	# as reserved words, because they cannot be overridden on bash and/or
	# ksh, so disabling them would not serve a compatibility purpose.
	#
	# TODO: reconsider this. This is impeding the ability to enhance
	#	native zsh with modernish.
#	case $- in
#	( *i* ) ;;
#	( * ) disable -r declare end float foreach integer local nocorrect repeat 2>/dev/null ;;
#	esac
	;;
esac

# ... pdksh and derivatives (oksh, mksh, lksh, ... ?)
case "${KSH_VERSION:-}" in
( '@(#)'* )
	set -o posix
	# mksh/lksh have UTF-8 support as of R38, but it needs to be turned on
	# explicitly with 'set -U'; the locale is not detected for scripts,
	# presumably for backwards compatibility with OpenBSD which only
	# supports ASCII. The recipe below is recommended by mksh's man page.
	case $KSH_VERSION in
	( '@(#)MIRBSD KSH '* | '@(#)LEGACY KSH '* )
		case ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} in
		( *[Uu][Tt][Ff]8* | *[Uu][Tt][Ff]-8* )
			set -U ;;
		( * )	set +U ;;
		esac ;;
	esac ;;
esac

# ... yash: it's very POSIX compliant even without posix mode, but unlike in
# other shells, posix mode disables non-standard functionality that scripts
# might want to test for and use (e.g. local variables, floating point arith).
# Yash in posix mode is also the only shell that honours the POSIX requirement
# that regular built-in utililities must have an existing external equivalent
# in order to be executed. This means that, in posix mode, yash will search
# $PATH before each execution of any regular built-in, which severely impacts
# performance.
# For these two reasons, perhaps it's better to leave posix mode off for yash.
# However, for compatibility testing purposes, it's very useful to turn it on,
# because it's the strictest POSIX compliance check available.
#case ${YASH_VERSION+s} in ( s ) set -o posix ;; esac

# ... external commands:
# TODO: reconsider whether to enable POSIX mode for external commands by default.
# For instance, setfacl/getfacl on Linux have badly reduced functionality in
# POSIX mode, even though they never made it past POSIX draft stage.
export POSIXLY_CORRECT=y	# this also sets -o posix on bash

# --- end of standards compliance requests ---

# -------------

# Initialization, phase 1.

# Modernish does _not_ support -e (-o errexit); for many commands, we need to
# be able to distinguish between "false" (1) and "error" (2 or greater) exit
# status, but 'set -e' falsely considers any non-zero exit status to be an
# error. What exit status indicates error depends on the particular command.
# Another problem is that individual shells vary widely with the exit status
# their builtins produce. More rationale: http://mywiki.wooledge.org/BashFAQ/105
# (and the inconsistencies mentioned there are just between bash versions...)
# Modernish provides a better alternative: the 'harden' function catches
# errors reliably on a command-by-command basis.
set +e

# Turn off 'allexport'. We're setting many read-only variables. Exporting
# all of them by default is not a good idea (even though they won't be
# read-only when inherited that way). Restore the option when we're done
# with initializing modernish. (The stack functions 'push' and 'pop'
# temporarily turn it off during execution because exporting the stack could
# cause bad things to happen.)
case $- in
( *a* )	set +a; _Msh_allexport=y ;;
( * )	unset -v _Msh_allexport ;;
esac

# Bash has the read-only variable $UID, as well as $USER which is not
# read-only. Give them to other shells too, and make both of them read-only.
case ${UID+s} in
( '' )	UID=$(id -u) || exit 127 ;;
esac
case ${USER+s} in
( '' )	USER=$(id -un) || exit 127 ;;
esac
readonly UID USER

# --- Shell feature, quirk, bug and POSIX compliance requirement checks ---
# Block on fatal shell bugs and standards incompatibilities that would break
# modernish. Identify quirks and nonstandard features. As a side effect,
# also do some of the initialization.
#
# Each feature, quirk and bug gets an identifier in MSH_CAP so scripts can
# test on them and work around them if necessary using the 'thisshellhas'
# function. Fatal bugs are blocked on unless $HOME/.modernish-force exists.
# (But they are considered fatal for a reason. Proceed at your own risk.)
#
# NOTE: all tests need to be compatible with all the bugs tested for (even
# the fatal ones), so that modernish can give a full report.

# MSH_CAP (capabilities; also quirks and bugs) is space-separated. Each ID in
# $MSH_CAP should only contain ASCII capital letters A-Z, digits 0-9, and (for
# bugs or quirks) the underscore. Maximum length per ID is 13 characters.
MSH_CAP=''

# Save $PATH for tests that need to change it.
_Msh_PATH=$PATH

# Save IFS (including its value and whether it is set or unset) to restore
# it at the end of the tests.
# Due to BUG_IFSISSET on ksh93, we can't test if IFS is set by any normal
# method, and we also can't know yet if we're on ksh93 or not, so use the
# workaround here, which is to analyse field splitting behaviour (this
# thankfully works on all shells).
_Msh_testFn() {
	case ${IFS:+n} in		# non-empty: it is set
	( '' )	set -- "a b c"		# empty: test for default field splitting
		set -- $1
		case $# in
		( 1 )	;;		# no field splitting: it is empty and set
		( 3 )	false ;;	# default field splitting: it is unset
		( * )	echo "modernish: Internal error with field splitting! Aborting." 1>&2
			exit 3 ;;
		esac ;;
	esac
}
_Msh_testFn && _Msh_IFS=$IFS || unset -v _Msh_IFS

# Helper variable and function.
_Msh_ftlcount=0
_Msh_have() {
	# IFS=' '	# avoid FTL_SUBSTIFS adding :s to MSH_CAP on old zsh [ TODO: check implications for testing code ]
	MSH_CAP=${MSH_CAP:+$MSH_CAP }$1
	case $1 in
	( FTL_* )
		( PATH=${_Msh_PATH}
		printf '[%s]\t%s\n' "$1" "$2" 1>&2 )		# Formats well if $1 is max 13 chars
		_Msh_ftlcount=$(( ${_Msh_ftlcount} + 1 ))	# FTL_NOARITH compatible addition
		;;
	esac
}

# The version and location of modernish.
# FTL_ROASSIGN: unpatched pdksh
readonly MSH_VERSION=0.04dev 2>| /dev/null
test "${MSH_VERSION:-}" = 0.04dev || _Msh_have FTL_ROASSIGN "'readonly' command doesn't support assignment."
MSH_SHELL=/bin/sh	# this line and the next will be changed by install.sh
MSH_PREFIX=${srcdir:-$PWD}
readonly MSH_SHELL MSH_PREFIX || _Msh_have FTL_ROSERIES "'readonly' can't make a series of variables read-only."

# For the next four tests, disable $PATH to avoid finding spurious
# external versions of 'alias', 'unalias' and 'command' (*BSD, Mac)
# for shells that don't have these built in.
# Don't use normal builtins (including 'test' and '[') without PATH set,
# or yash in POSIX mode won't find them (as POSIX mandates).
PATH=/dev/null

# FTL_NOALIAS: No aliases (Debian posh; bash "minimal configuration").
alias test=test || _Msh_have FTL_NOALIAS 'No support for aliases at all.'

# FTL_UNALIASA: Can't remove all aliases.
\unalias -a 2>| /dev/null \
|| case ${ZSH_VERSION+s} in
( s )	\unalias -m '*' ;;
( * )	false ;;
esac || _Msh_have FTL_UNALIASA "No support for 'unalias -a'."

# Make sure that we have a way to guarantee running a shell builtin.
# Note: we can only use 'special builtins' here or yash in posix mode will fail this test.
# See: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_14
# FTL_NOCOMMAND: Debian posh; zsh < 4.2
{	unset -f command
	_Msh_test=x
	command -v unset \
	&& command -V unset \
	&& command -p unset _Msh_test \
	&& case ${_Msh_test+s} in ( s ) false ;; esac
} >| /dev/null 2>&1 || _Msh_have FTL_NOCOMMAND "No or broken 'command' builtin."

# On some shells (e.g. mksh), the POSIX 'type' command is an alias. We just
# killed it, so restore it, to avoid it being either missing or run as an
# external command (where the results w.r.t. what is a builtin don't apply
# to the currrent shell).
# In all the shells I've tested except bash (which has 'type -t'), the
# 'type' output is exactly equivalent to 'command -V' (capital V). However,
# POSIX standardises 'command -V' in more detail than it does 'type', while
# every possible output of 'command -V' also matches the less-detailed
# definition of 'type'.
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.html
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/type.html
case " $MSH_CAP " in
( *' FTL_NOALIAS '* ) ;;	# skip: not applicable
( * )	command -V type >| /dev/null 2>&1 || alias type='command -V' ;;
esac

PATH=${_Msh_PATH}

# FTL_DEVCLOBBR: Can't write to devices if 'set -o noclobber' is active.
# Workaround: use >| instead of >
# (NetBSD /bin/sh)
( set -C; : >/dev/null ) 2>|/dev/null || _Msh_have FTL_DEVCLOBBR "Can't redirect to devices if 'set -o noclobber'."

# Test for complete POSIX shell arithmetics support. Run test in a subshell
# because shells exit on 'syntax error', thwarting our error message.
# Test for arithmetic:
#	- additive assignment (+=)
#	- comparison (==, >)
#	- conditional expression (x?y:z)
#	- hexadecimal numbers (0x2A == 42)
#	- octal numbers (014 == 12, 015 == 13)
# FTL_NOARITH: NetBSD /bin/sh, Slackware /bin/ash, original pdksh (no hex or octal).
(	i=7
	j=0
	test "$(( ((j+=6*i)==0x2A)>0 ? 014 : 015 ))" -eq 12 && test "$j" -eq 42
) 2>| /dev/null || _Msh_have FTL_NOARITH "Incomplete and/or broken POSIX shell arithmetics."

# pdksh 5.2.14nb5 from NetBSD pkgsrc has a very obscure bug: it fails to
# match a list of characters from a variable in a bracket pattern, but only
# if the variable name is exactly 14 characters long! (It breaks
# shellquote() because $SHELLSAFECHARS, which it uses in a bracket
# pattern, is a 14 character variable name.)
_Msh_test_1234=x	# 14 character variable name
case x in
( [${_Msh_test_1234}] ) ;;
( * )	_Msh_have FTL_FOURTEEN "Problem with 14 characters long variable names." ;;
esac
unset -v _Msh_test_1234

# FTL_PARONEARG: When IFS is empty on most versions of pdksh (i.e. field
# splitting is off), "$@" is counted as a single argument instead of each
# positional parameter as separate arguments. This is unlike every other
# shell and contrary to the standard as the working of "$@" is unrelated to
# field splitting. Sadly this means neither of NetBSD's or OpenBSD's default
# shells can run modernish.
#
# BUG_PARONEARG: When IFS is empty on bash 3.x and 4.x (i.e. field splitting
# is off), ${1+"$@"} (the BUG_UPP workaround for "$@") is counted as a
# single argument instead of each positional parameter as separate
# arguments. This is unlike every other shell and contrary to the standard
# as the working of "$@" is unrelated to field splitting.
# This bug renders the most convenient workaround for BUG_UPP ineffective on
# bash under 'use safe' settings which include 'set -o nounset' and empty
# IFS. :( Not that any version of bash has BUG_UPP, but cross-platform
# compatibility is hindered by this.
IFS=''
_Msh_testFn() {
	_Msh_testFn2 "$@" || { _Msh_have FTL_PARONEARG \
	'"$@" becomes one single argument if field splitting is disabled.'	# pdksh, oksh, posh, mksh before R44
	return; }
	_Msh_testFn2 ${1+"$@"} || _Msh_have BUG_PARONEARG			# bash 3.x and 4.x; old zsh 4.x
}
_Msh_testFn2() {
	case $# in
	( 1 )	return 1 ;;
	( 4 )	;;
	( * )	_Msh_have FTL_PARNEWBUG 'Undiscovered bug with "$@"! Please report.' "($#)" ;;
	esac
}
_Msh_testFn "   \on\e" "\tw'o" " \th\'re\e" " \\'fo\u\r "

# FTL_SUBSTIFS: parameter substitution changes all existing spaces in the
# variable to the first character in IFS. (zsh 4.1.1)
_Msh_test='1 2 3'
IFS='x '  # this zsh bug is only triggered if IFS has space as 2nd char
_Msh_test=${_Msh_test+$_Msh_test }4\ 5
IFS=' '
case ${_Msh_test} in
( '1 2 3 4 5' )	;;
( '1x2x3 4 5' )	_Msh_have FTL_SUBSTIFS "Parameter substitution changes spaces to IFS char." ;;
( '*' )		_Msh_have FTL_PSTNEWBUG "Undiscovered bug with parameter substitution! (${_Msh_test})" ;;
esac

# FTL_PSUB: parameter substitution fails to match certain
# patterns. (yash < 2.40)
#  *  The parameter expansion ${foo##bar*} was being treated like
#     ${foo##bar} where the asterisk should match up to the end of the
#     parameter value.
#  *  The parameter expansion ${foo%%*} was being expanded to ${foo}
#     where it should expand to an empty string.
_Msh_test='barbarfoo'
case ${_Msh_test##bar*}/${_Msh_test%%*} in
( / )	;;
( barfoo/barbarfoo )
	_Msh_have FTL_PSUB "Parameter substitution fails to match certain patterns.${YASH_VERSION+ (yash 2.40 fixes this)}" ;;
( * )	_Msh_have FTL_PSUBNEW "Undiscovered bug with parameter substitution! (${_Msh_test})" ;;
esac

# FTL_EVALRET: shell doesn't return from a function if the "return"
# is within an 'eval', but only from the 'eval'. (yash < 2.39)
# http://osdn.jp/ticket/browse.php?group_id=3863&tid=35232
# (In modernish 0.02dev this was a non-fatal BUG_EVALRET and the code
# included workarounds, but yash up to 2.39 turns out to have FTL_PSUB,
# so we can stop working around bugs from that version and before.)
_Msh_testFn() { true; eval "return $?"; false; }
if ! _Msh_testFn; then
	_Msh_have FTL_EVALRET "No return from function if 'return' within 'eval'.${YASH_VERSION+ (yash 2.39 fixes this)}"
fi

# FTL_ROUNDMLN: AT&T ksh version "M 1993-12-28 s+" (pre-installed version
# on Mac OS X 10.7) has rounding errors in integer arithmetic when ordinary
# shell assignments or comparisons are used on numbers greater than one
# million; only pure shell arithmetic expressions work (up to 64 bits).
# FTL_ARITHASGN: Arithmetic assignment fails if the variable already
# contains a value that cannot be converted to arithmetic. (yash < 2.40)
case " $MSH_CAP " in
( *" FTL_NOARITH "* ) ;;  # Skip: not applicable.
( * )	PATH=/dev/null
	typeset -i _Msh_test2 2>|/dev/null  # suppress ksh93 rendering variable as float exponential
	PATH=${_Msh_PATH}
	_Msh_test2=$((1000005))
	_Msh_test=foobar
	( : "$((_Msh_test = 1000005))" ) 2>|/dev/null && : "$((_Msh_test = 1000005))"
	case "${_Msh_test2},$((1000001)),$((1000005)),${_Msh_test}" in
	( 1000005,1000001,1000005,1000005 ) ;;
	( 1000005,1000001,1000005,foobar )
		_Msh_have FTL_ARITHASGN "Arith assignment fails after string assignment. ${YASH_VERSION+(yash 2.40 fixes this)}" ;;
	( 1000010,1e+06,1*00001e+06,1000005 )
		_Msh_have FTL_ROUNDMLN 'Broken shell assignment/comparison: rounding errors after 1 million' ;;
	( * )	_Msh_have FTL_ROUNDNEW "Undiscovered bug in shell arith! (${_Msh_test2},$((1000001)),$((1000005)),${_Msh_test})" ;;
	esac
	unset -v _Msh_test2  # undo typeset -i
	;;
esac

# FTL_TRAPFUNC: EXIT traps act on exiting functions. This defeats
# 'pushtrap' and 'poptrap'. (zsh < 4.3.11)
unset -v _Msh_test
_Msh_testFn() {
	trap _Msh_test=1 EXIT
}
_Msh_testFn
case ${_Msh_test+s} in
( s )	_Msh_have FTL_TRAPFUNC "EXIT traps act on functions${ZSH_VERSION+ (no POSIX_TRAPS; zsh 4.3.11 fixes this)}" ;;
esac
trap - EXIT

# FTL_NOFNOVER: Can't override shell builtins with shell functions. (ksh88)
{ echo() { :; }; } 2>/dev/null && unset -f echo || _Msh_have FTL_NOFNOVER "Can't override shell builtins with functions."

# --- Non-fatal bug tests ---

# BUG_UPP (Unset Positional Parameters): Cannot access "$@" or "$*" if set -u
# (-o nounset) is active and there are no positional parameters. If that
# option is set, NetBSD /bin/sh and older versions of ksh93 and pdksh error
# out on accessing "$@" and "$*" (the collective positional parameters), even
# if that access is implicit in a 'for' loop (as in 'for var do stuff; done').
# This is against the standard:
#     "-u: When the shell tries to expand an unset parameter OTHER THAN THE
#     '@' AND '*' SPECIAL PARAMETERS, it shall write a message to standard
#     error and shall not execute the command containing the expansion [...]".
# Unfortunately, ksh93 with this bug is still too common to block on this.
# Reference:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_25_03
# (under '-u').
# This is a bug making 'use safe' less convenient to work with. Workarounds
# are necessary in library code (search for BUG_UPP to find them).
# The following workarounds are the most convenient:
#	* Instead of "$@", use: ${1+"$@"}
#	* Instead of "$*", use: ${1+"$*"}
#	* Instead of 'for var do', use: 'for var in ${1+"$@"}; do'
# However, BUG_PARONEARG in bash makes these impossible when under 'use safe'!
# Universally compatible workarounds include:
#	* Testing 'if thisshellhas BUG_UPP' before using the above workarounds;
#	  no shell is known to exist that has both BUG_UPP and BUG_PARONEARG.
#	* Testing that $# is greater than 0 before accessing "$@" or "$*".
#	* Using "${@:-}" instead of "$@" and coping with an extra empty argument
#	  if there are no positional parameters (note: "${@-}" without the ':'
#	  does not work on all shells).
# The 'safe' module will refuse to initialize by default if BUG_UPP is found.
# To 'use safe' on a shell with this bug, say:
#     use safe -w BUG_UPP
# to get around the block, and implement workarounds in your script as above.
if ! ( set -u --; dummy="$@"; dummy="$*"; for dummy do :; done; ) 2>| /dev/null
then
	_Msh_have BUG_UPP
fi

# BUG_FNSUBSH: Function definitions within subshells (including command
# substitutions) are ignored if a function by the same name exists in
# the main shell, so the wrong function is executed. (Unsetting of functions
# is also ignored, as is setting/unsetting of aliases.)
# ksh93 (all current versions as of 2015) has this bug.
#
# BUG_ALSUBSH: Aliases defined within subshells leak upwards to the main shell.
# (found in ksh93 versions "M 1993-12-28 s+", "JM 93t+ 2010-03-05")
_Msh_testFn() { echo main; }
case $( alias BUG_ALSUBSH=true; _Msh_testFn() { echo sub; }; _Msh_testFn ) in
( sub )  ;;
( main ) _Msh_have BUG_FNSUBSH ;;
( * )    _Msh_have FTL_FNSUBSH 'Undiscovered bug with functions in subshells!' ;;
esac
alias BUG_ALSUBSH >|/dev/null 2>&1 && _Msh_have BUG_ALSUBSH
	# don't unalias the alias that leaked from the subshell, so that the main shell
	# can detect it and implement a workaround. This method is used in install.sh.

# BUG_MULTIBYTE: We're running on a locale with a variable-length character
# set (i.e. UTF-8) but the shell does not support multi-byte characters. For
# instance, ${#var} measures length in bytes, not characters. With
# fixed-length one-byte character sets, the bug is irrelevant so we don't
# set the identifier. Current shells with this bug include dash and most
# branches of pdksh.
# Note: Currently, BUG_MULTIBYTE is only detected if we're in a UTF-8 locale.
# It should not be detected for single-byte locales as it's irrelevant there.
# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_02
# TODO? Make test reliable. Figure out what all the variable-length
#	character sets are and implement tests for all of them.
#	(Or maybe not; UTF-8 is de facto standard, so why bother?)
case ${LC_ALL:-${LC_CTYPE:-${LANG:-}}} in
( *.[Uu][Tt][Ff]8 | *.[Uu][Tt][Ff]-8 )
	_Msh_test='bèta' # 4 char, 5 byte UTF-8 string 'beta' with accent grave on 'e'
	case ${#_Msh_test} in
	( 4 )	;;
	( 5 )	_Msh_have BUG_MULTIBYTE ;;
	( * )	_Msh_have FTL_UTFLENGTH "Fatal error in measuring UTF-8 string length. (${#_Msh_test})" ;;
	esac ;;
esac

# BUG_NOUNSETRO: Cannot freeze variables as readonly in an unset state.
# This bug in zsh < 5.0.8 makes the 'readonly' command set them to the
# empty string instead. For BUG_NOUNSETRO compatibility, modernish library
# code should not depend on the unset status of read-only variables.
# Notes on test compatibility with other shell bugs:
# * For BUG_UNSETFAIL compatibility, don't use 'unset ... && readonly ...'
# * ksh93 version "M 1993-12-28 r" has a parsing bug: it will erroneously
#   stop script execution on
#	test "${_Msh_ReadOnlyTest+set}" = ""
#   with a "_Msh_ReadOnlyTest: read-only variable" error, indicating the
#   wrong line number. But this ONLY happens if that command is in a
#   subshell! Yet it stops the main script! So to avoid locking out ksh93,
#   don't use a subshell (this speeds up our init anyway) and accept that we
#   have a permanent _Msh_ReadOnlyTest unset readonly.
unset -v _Msh_ReadOnlyTest
readonly _Msh_ReadOnlyTest
test "${_Msh_ReadOnlyTest+set}" = "" || _Msh_have BUG_NOUNSETRO

# BUG_EMPTYBRE is a 'case' pattern matching bug in zsh: empty bracket
# expressions eat subsequent shell grammar, producing unexpected results (in
# the test example below, a false positive match, because the two patterns
# are taken as one, with the "|" being taken as part of the bracket
# expression rather than shell grammar separating two bracket expressions).
# This is particularly bad if you want to pass a bracket expression using a
# variable or parameter, and that variable or parameter could be empty. This
# means the grammar parsing depends on the contents of the variable!
# This is fixed as of zsh 5.0.8, but *only* in POSIX/'emulate sh' mode.
# (yash < 2.15 also had this bug.)
_Msh_test=''
case abc in
( ["${_Msh_test}"] | [!a-z]* )
	_Msh_have BUG_EMPTYBRE
esac

# BUG_HASHVAR: On zsh, $#var means the length of $var - other shells and
# POSIX require braces, as in ${#var}. This causes interesting bugs when
# combining $#, being the number of positional parameters, with other
# strings. For example, in arithmetics: $(($#-1)), instead of the number of
# positional parameters minus one, is interpreted as ${#-} concatenated with
# '1'. So, for zsh compatibility, always use ${#} instead of $# unless it's
# stand-alone or followed by a space.
# zsh 5.0.8 fixes this bug, but *only* in POSIX/'emulate sh' mode.
_Msh_test=$$	# another bug on zsh 4.3.11 is that ${#$} is a bad
		# substitution, even though $#${var} resolves to ${#$}{var};
		# we're assigning $$ to the variable as a workaround
case $#${_Msh_test},$(($#-1+1)) in
( "${#}${$},${#}" ) ;;
( "${#_Msh_test}{_Msh_test},${#-}2" | "${#_Msh_test}{_Msh_test},2" )
	# the second bug pattern applies if ${#-} is zero (i.e. no shell
	# options active); this happens if zsh is launched as 'sh'
	_Msh_have BUG_HASHVAR ;;
( * ) _Msh_have FTL_HASHVAR "Undiscovered bug with parameter expansion involving \$# ($#${_Msh_test},$(($#-1+1)))" ;;
esac

# BUG_READTWHSP: 'read' does not trim trailing IFS whitesace if there is
# more than one field. (dash) https://bugs.debian.org/794965
# FTL_READLWHSP: 'read' does not trim leading IFS whitespace. (yash < 2.39)
# http://osdn.jp/ticket/browse.php?group_id=3863&tid=35265
# (This is upgraded to a 'fatal' bug because the only shell known to have
# this bug turns out to have other fatal bugs.)
# FTL_READAWHSP: 'read' does not trim any IFS whitespace. (yash < 2.8)
# (NOTE: in here-document below: two leading spaces and two trailing spaces!)
IFS=' ' read _Msh_test <<-EOF
  ab  cd  
EOF
case ${_Msh_test} in
('ab  cd')	;;
('ab  cd  ')	_Msh_have BUG_READTWHSP ;;
( '  ab  cd')	_Msh_have FTL_READLWHSP "'read' does not trim leading IFS whitesapce.${YASH_VERSION+ (yash 2.39 fixes this)}" ;;
('  ab  cd  ')	_Msh_have FTL_READAWHSP "'read' does not trim any IFS whitespace.${YASH_VERSION+ (yash 2.8 fixes this)}" ;;
( * )		_Msh_have FTL_READWHSP "Undiscovered IFS whitespace bug with 'read'. ('${_Msh_test}')" ;;
esac

# BUG_APPENDC: On zsh < 5.1, when set -C (noclobber) is active, "appending" to
# a nonexistent file with '>>' throws an error rather than creating the file.
# This is long-standing zsh behaviour, but is contrary to the POSIX spec and
# different from every other shell, so it's a legit POSIX compliance bug.
# The error may cause the shell to exit, so must fork a subshell to test it.
# This is another bug affecting 'use safe'.
# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_07_03
#	http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_25
if ! [ -d /tmp ] || ! [ -w /tmp ] || ! [ -x /tmp ]; then
	_Msh_have FTL_NOTMP "/tmp directory not found or not writable!"
elif !	(	umask 077
		set -C
		# Find a nonexistent filename
		i=$$
		until F=/tmp/_Msh_BUG_APPENDC.$i && ! [ -L "$F" ] && ! [ -e "$F" ]; do
			i=$(( $i + $$ ))
		done
		# Test if "appending" creates it
		: >> "$F" && { rm -f "$F" & }
	) 2>| /dev/null
then
	_Msh_have BUG_APPENDC
fi

# BUG_UNSETFAIL: the 'unset' command sets a non-zero (fail) exit status if
# the variable to unset was either not set (some pdksh versions), or never
# set before (AT&T ksh 1993-12-28). This is contrary to POSIX, which says:
# "Unsetting a variable or function that was not previously set shall not be
# considered an error [...]". Reference:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_29_03
# Good thing we don't support "set -e". Still, this bug can affect the exit
# status of functions and dot scripts if 'unset' is the last command.
unset -v _Msh_test
if ! unset -v _Msh_test; then
	_Msh_have BUG_UNSETFAIL
fi

# BUG_CMDVRESV: 'command -v' does not find reserved words such as "if", contrary
# to POSIX. This bug affects modernish's thisshellhas function. The bug is in
# mksh R50f (2015/04/19) and earlier, as well as its ancestor pdksh and its variants.
# Fixed in mksh R51 (2015/07/05).
# Ref: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.html#tag_20_22
PATH=/dev/null
command -v if >| /dev/null 2>&1 || _Msh_have BUG_CMDVRESV
PATH=${_Msh_PATH}

# QRK_IFSFINAL: in field splitting, a final non-whitespace IFS delimiter
# character is counted as an empty field (yash, zsh, pdksh)
# The POSIX standard is pretty ambiguous on this:
# https://osdn.jp/ticket/browse.php?group_id=3863&tid=35283#comment:3863:35283:1435293070
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_05
# http://www.mail-archive.com/bug-bash@gnu.org/msg05283.html
# It's a QRK (quirk), not a BUG, because it's not clear that the uncommon
# field splitting behaviour is a POSIX compliance bug, but it's certainly in
# the minority among shells.
#
# Also test for fatal fieldsplitting bugs in other shells. The ones
# involving backslashes would break shellquote() in particular. To make sure
# shellquote() works correctly, also include single quotes in the test.
IFS=': '
_Msh_test='  ::  \on\e :\tw'\''o \th\'\''re\e :\\'\''fo\u\r:   : :  '
_Msh_testFn() {
	IFS=' '	# avoid FTL_SUBSTIFS adding :s to MSH_CAP on old zsh
	case ${#},${1-U},${2-U},${3-U},${4-U},${5-U},${6-U},${7-U},${8-U},${9-U},${10-U},${11-U},${12-U}, in
	( '8,,,\on\e,\tw'\''o,\th\'\''re\e,\\'\''fo\u\r,,,U,U,U,U,' )
		# no quirks or bugs (bash, ash, dash, ksh93, mksh, ...)
		;;
	( '9,,,\on\e,\tw'\''o,\th\'\''re\e,\\'\''fo\u\r,,,,U,U,U,' )
		# zsh, yash
		_Msh_have QRK_IFSFINAL
		;;
	( '11,,,\on\e,,\tw'\''o,\th\'\''re\e,,\\'\''fo\u\r,,,,U,' )
		# pdksh
		_Msh_have QRK_IFSFINAL
		_Msh_have FTL_IFSWHSP "Field splitting: incorrect IFS whitespace removal."
		;;
	( '9,,,on\e,tw'\''o,th\'\''re\e,\'\''fo\u\r,,,,U,U,U,' )
		# yash 2.8 to 2.37
		_Msh_have QRK_IFSFINAL
		_Msh_have FTL_IFSBKSL "Field splitting eats initial backslashes.${YASH_VERSION+ (yash 2.38 fixes this)}"
		;;
	( '9,,,\on\e,\tw'\''o,\th\'\''re\e,\'\''fo\u\r,,,,U,U,U,' )
		# zsh up to 4.2.6
		_Msh_have QRK_IFSFINAL
		_Msh_have FTL_IFSEFODB "Field splitting eats first of double backslash.${ZSH_VERSION+ (zsh 4.2.7 fixes this)}"
		;;
	( '8,,\on\e,\tw'\''o,\th\'\''re\e,\\'\''fo\u\r,,,,U,U,U,U,' )
		# ksh93 Version M 1993-12-28 p
		# Bug with IFS whitespace: an initial empty whitespace-separated field
		# appears at the end of the expansion result instead of the start
		# if IFS contains both whitespace and non-whitespace characters.
		# TODO: should be fatal? It doesn't affect shellquote().
		_Msh_have BUG_IFSWHSPE
		;;
	( '1,  ::  \on\e :\tw'\''o \th\'\''re\e :\\'\''fo\u\r:   : :  ,U,U,U,U,U,U,U,U,U,U,U,' )
		_Msh_have FTL_NOFSPLIT "No field splitting. (Native zsh mode?)"
		;;
	( * )	_Msh_have FTL_IFSNWBUG "Undiscovered quirk or bug with field splitting! Please report. (${#},${1-U},${2-U},${3-U},${4-U},${5-U},${6-U},${7-U},${8-U},${9-U},${10-U},${11-U},${12-U},)"
		;;
	esac
}
_Msh_testFn ${_Msh_test}

# BUG_TESTILNUM: On dash (up to 0.5.8), giving an illegal number to 'test -t'
# or '[ -t' causes some kind of corruption so the next 'test'/'[' invocation
# fails with an "unexpected operator" error even if it's legit. This affects
# checking the exit status of the previous 'test' with 'test'. After the
# corrupted invocation, 'test' will function normally again. So isonterminal()
# needs a workaround with 'case' and a dummy invocation of 'test' (see there).
{
	[ -t 12323454234578326584376438 ]	# "illegal number"
	[ "$?" -gt 1 ]				# trigger bug
} 2>| /dev/null
case $? in
( 0 | 1 ) ;;
( * ) _Msh_have BUG_TESTILNUM ;;
esac

# BUG_TESTPAREN: Incorrect parsing of unary test/[ operators (-n, -z, -e, etc.)
# with values '(', ')' or '!' in zsh 5.0.6 and 5.0.7. This means test/[ cannot
# test for non-emptiness of values that may be '(', ')' or '!' or for the
# existence of files with those exact names. This can make scripts that process
# arbitrary data (e.g. the shellquote function) take the wrong action unless
# workarounds are implemented or modernish equivalents are used instead.
# Workarounds:
# - Instead of [ -z "$var" ], use one of:
#	empty "$var"		# the modernish way
#	let "! ${#var}"		# test length of value
#	[ -z "${var:+n}" ]	# the only possible values: 'n' or empty
#				# (but circumvents 'set -o nounset' ('set -u'))
# - Instead of [ -n "$var" ], use one of:
#	not empty "$var"
#	let "${#var}"
#	[ -n "${var:+n}" ]
{ [ -n '(' ] && [ -n ')' ] && [ -n '!' ]; } 2>| /dev/null \
|| _Msh_have BUG_TESTPAREN

# BUG_TESTRMPAR: zsh: in binary operators with 'test'/'[', if the first
# argument starts with '(' and the last with ')', both the first and the last
# argument are completely removed, leaving only the operator, and the result of
# the operation is incorrectly true because the operator is incorrectly parsed
# as a non-empty string, as in [ "$v" ]. This applies to all the binary
# operators, including string comparisons and file comparisons.
# Ref.: http://www.zsh.org/mla/workers/2015/msg03275.html
# * Workarounds for string comprisons:
#   Instead of [ "$foo" = "$bar" ],
#   - either use modernish: identic "$foo" "$bar"
#   - or do what POSIX recommends anyway and start the strings with a protector
#     character when comparing arbitrary data: [ "X$foo" = "X$bar" ]
# * Workarounds for file comparisons ([ "$1" -nt/-ot/-ef "$2" ]):
#   None known, except to use '[[' instead.
# * The bug also applies to arithmetic comparison ([ "$1" -eq "$2" ], etc.)
#   but this is only relevant for invalid values; still, '[' will produce
#   false positives if erroneous data is fed according to this bug pattern,
#   for example:   x='(1'; y=')2'; [ "$x" -eq "$y" ]   will yield true.
[ '(a' = ')b' ] && _Msh_have BUG_TESTRMPAR

# BUG_TESTERR0: mksh: 'test'/'[' exits successfully (exit status 0) if
# an invalid argument is given to an operator. (mksh R52 fixes this)
# BUG_TESTERR1A: AT&T ksh: 'test'/'[' exits with a non-error 'false' status
# (1) if an invalid argument is given to an operator.
# (zsh 4.1.1 needs 'eval' here to stop main shell from exiting on this error)
eval '[ 123 -eq 1XX ]' 2>| /dev/null
case $? in
( 0 ) _Msh_have BUG_TESTERR0A ;;
( 1 ) _Msh_have BUG_TESTERR1A ;;
esac

# BUG_TESTERR1B: zsh: 'test'/'[' exits with status 1 (false) if there are
# too few or too many arguments, instead of a status > 1 as it should do.
# (zsh 5.3 fixes this)
# (zsh 4.1.1 needs 'eval' here to stop main shell from exiting on this error)
eval '[ 123 -eq ]' 2>| /dev/null
case $? in
( 0 ) _Msh_have FTL_TESTERR0B "Undiscovered bug with syntactically invalid 'test'/'[' expressions!" ;;
( 1 ) _Msh_have BUG_TESTERR1B ;;
esac

# BUG_CMDSPCIAL: zsh; mksh < R50e: 'command' does not turn off the 'special
# built-in' characteristics of special built-ins, such as exit shell on error.
# Ref.:	http://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.html#tag_20_22
#	"If the command_name is the same as the name of one of the special
#	built-in utilities, the special properties in the enumerated list at
#	the beginning of Special Built-In Utilities shall not occur."
# Hopefully -@ is an invalid option on every shell...
case " $MSH_CAP " in
( *" FTL_NOCOMMAND "* )	;;	# skip: not applicable
( * )	( command set -@; : ) 2>| /dev/null || _Msh_have BUG_CMDSPCIAL ;;
esac

# BUG_PSUBBKSL (bash 2 & 3, standard dash, Busybox ash)
# A backslash-quoted character within a parameter substitution is not unquoted.
#	Note: quoting a '}' with anything other than a backslash *within* a
#	parameter substitution, e.g. ${var+"\}"}, is invalid as that may be
#	considered an unbalanced quote (") within ${...}. In practice, shells
#	produce varying results, although none actually gives an error. See
#	http://www.unix.org/whitepapers/shdiffs.html under "Parameter
#	Expansion".
# Note: for the detection of this bug it is important that the whole
# substitution is quoted, even though this is not supposed to make a
# difference in 'case'.
_Msh_test=somevalue
case "${_Msh_test+\}}" in
( '}' ) ;;
( '\}' ) _Msh_have BUG_PSUBBS2 ;;
( * )	_Msh_have FTL_PSSUBS2 "Undiscovered bug with backslash in parameter substitution!" ;;
esac

# BUG_ARITHTYPE: In zsh < 5.3, arithmetic assignments (using 'let', '$(( ))',
# etc.) on unset variables assign a numerical/arithmetic type to a variable,
# causing subsequent normal variable assignments to be interpreted as
# arithmetic expressions and fail if they are not valid as such. This is an
# incompatibility with the POSIX shell, which is a typeless language.
# To work around this bug, either make sure variables are not used for a
# non-integer data type after arith assignment, or set them to an empty
# value before using them.
case " $MSH_CAP " in
( *" FTL_NOARITH "* )	;;	# skip: not applicable
( * )	(	unset -v _Msh_test
		: $((_Msh_test = 1))
		_Msh_test=a:b:c  # zsh: bad math expression: ':' without '?'
	) 2>|/dev/null || _Msh_have BUG_ARITHTYPE ;;
esac

# QRK_ARITHWHSP: In yash and FreeBSD /bin/sh, trailing whitespace from
# variables is not trimmed in arithmetic expansion, causing the shell to
# exit with an 'invalid number' error. POSIX is silent on the issue.
# https://osdn.jp/ticket/browse.php?group_id=3863&tid=36002
case " $MSH_CAP " in
( *" FTL_NOARITH "* )	;;	# skip: not applicable
( * )	case $(	_Msh_test='	 1'		# tab, space, 1
		: $((_Msh_test)) || exit	# (need 'exit' because yash in interactive mode doesn\'t) [BUG_CSCMTQUOT compat]
		echo a1
		_Msh_test='1	 '		# 1, tab, space
		: $((_Msh_test)) || exit
		echo a2
	) in
	( '' )	_Msh_have FTL_ARITHWHSP 'Undiscovered whitespace quirk in arithmetic expansion! Please report.' ;;
	( a1 )	_Msh_have QRK_ARITHWHSP ;;
	( a1*a2 ) ;;
	( * )	_Msh_have FTL_ARITHWHSP 'Internal error in QRK_ARITHWHSP test! Please report.' ;;
	esac 2>|/dev/null ;;
esac

# BUG_IFSISSET: From the AT&T ksh93 changelog:
# 13-06-20  A bug in which  ${IFS+abc} did not expand to abc when IFS is
#           unset has been fixed.
# This introduces a bug, it doesn't fix one. The parameter substitution
# ${var+x} is not supposed to expand to anything if 'var' is unset. IFS is not
# special in this regard, and ksh93 as of 2013-06-20 is unique in the POSIX
# world with this behaviour. Even its proprietary 'test -v' (to test if a
# variable is set) is affected. So on recent ksh93, the only way to test if
# IFS is set or not is by analysing the shell's field splitting behaviour.
unset -v IFS
case ${IFS+s} in
( '' )	;;
( s )	_Msh_have BUG_IFSISSET ;;
esac
IFS=' '

# QRK_32BIT: the shell only has 32-bit arithmetics. Since every modern
# system these days supports 64-bit long integers even on 32-bit kernels, we
# can now count this as a quirk.
# mksh has it (on purpose). For 64-bit arithmetics, run lksh instead.
case " $MSH_CAP " in
( *" FTL_ROUNDMLN "* ) ;;  # not applicable
( * )	case $((2147483650)) in
	( 2147483650 ) ;;
	( -2147483646 | 2147483647 ) _Msh_have QRK_32BIT ;;
	( * ) _Msh_have FTL_32BIT "Undiscovered bug with 32-bit arithmetic wraparound!" ;;
	esac ;;
esac

# BUG_NOCHCLASS: character [:classes:] within bracket [expressions] are not
# supported in glob patterns. (pdksh, mksh, and family, except OpenBSD ksh)
#	On OpenBSD and NetBSD, the C globbing function fnmatch(3) is broken:
#	it has character class support, but negated character classes like
#	[![:space:]] don't work. This affects the dash shell in OpenBSD ports
#	which is configured to use fnmatch(3). Class this as same bug since
#	buggy character classes should not be considered reliable at all.
# This bug affects isint() in main and trim() in var/string.mm.
# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_13_01
#   and http://pubs.opengroup.org/onlinepubs/9699919799/basedefs/V1_chap09.html#tag_09_03_05
case x in
( [[:alnum:]] )
	case x in
	( [![:space:]] ) ;;
	( * ) _Msh_have BUG_NOCHCLASS ;;	# fnmatch(3) on OpenBSD 5.8
	esac ;;
( * )	_Msh_have BUG_NOCHCLASS ;;		# pdksh/mksh/etc (but not OpenBSD ksh)
esac

# BUG_BRACQUOT: shell quoting within bracket patterns has no effect (zsh < 5.3;
# ksh93) This bug means the '-' retains it special meaning of 'character
# range', and an initial '!' (and, on some shells, '^') retains the meaning of
# negation, even in quoted strings within bracket patterns, including quoted
# variables. This makes it difficult to pass arbitrary strings of characters to
# match against using a bracket pattern. Workaround: make sure the '-' is last
# in the string of characters to match, and the string does not start with '^'
# or '!'.
# This bug requires a workaround for trim() in var/string.mm, and it's also the
# reason the '-' needs to always be last in the readonly SHELLSAFECHARS.
case b in
( ['a-c'] | ["!"a] ) _Msh_have BUG_BRACQUOT ;;
( [a-c] ) ;;
( * ) _Msh_have FTL_BRACNWBUG "Undiscovered bug with bracket pattern matching!" ;;
esac

# BUG_CSCMTQUOT: unbalanced single and double quotes and backticks in comments
# within command substitutions cause obscure and hard-to-trace syntax errors
# later on in the script. (ksh88; pdksh, incl. {Open,Net}BSD ksh; bash 2.05b)
( eval ': $( : # dummy comment with unbalanced quote"
	)' ) 2>/dev/null || _Msh_have BUG_CSCMTQUOT

# QRK_EVALNOOPT: 'eval' does not parse options, not even '--', which makes it
# incompatible with other shells: on the one hand, (d)ash does not accept
# 'eval -- "$command"' whereas on other shells this is necessary if the command
# starts with a '-', or the command would be interpreted as an option to
# 'eval'. A simple workaround is to prefix arbitary commands with a space. See:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_19_16
# Both situations are POSIX compliant, but since they are incompatible
# without a workaround, let's label the minority situation as a QuiRK.
PATH=/dev/null	# avoid any external command called '--'
if ! eval -- ':' 2>/dev/null; then
	_Msh_have QRK_EVALNOOPT
fi
PATH=${_Msh_PATH}

# BUG_BRACSQBR: the closing square bracket ']', even if escaped or passed
# from a quote variable, produces a false positive in negated ('!') bracket
# patterns, i.e. the pattern is never matched. (FreeBSD /bin/sh)
# (This bug is the reason why $SHELLSAFECHARS can't contain ']'; it would
# break shellquote() on the shell with this bug)
case e in
( *[!ab\]cd]* ) ;;
( * )	_Msh_have BUG_BRACSQBR ;;
esac

# BUG_CMDPV: 'command -pv' does not find builtins. ({pd,m}ksh, zsh)
PATH=/dev/null
command -pv : >|/dev/null 2>&1 || _Msh_have BUG_CMDPV
PATH=${_Msh_PATH}

# BUG_FNREDIR: I/O redirections on function definition commands are not
# remembered or honoured when the function is executed. (zsh4)
# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_09_05
#	On zsh, his test function produces a false positive:
#		_Msh_testFn() { echo hi; } 1>&-
#	because zsh incorrectly returns with exit status 0 on failing to
#	write to a closed stdout. The following does work on zsh. However,
#	zsh exits on the resulting write error, so we need a subshell.
_Msh_testFn() { echo hi 1>&2; } 2>&-
(_Msh_testFn) 2>|/dev/null && _Msh_have BUG_FNREDIR

# BUG_PSUBPAREN: Parameter substitutions where the word to substitute contains
# parentheses wrongly cause a "bad substitution" error. (pdksh)
( : "${var+(word)}" ) 2>/dev/null || _Msh_have BUG_PSUBPAREN

# --- Test for incompatible combinations of bugs ---
# Some combinations of bugs make workarounds very tedious if they
# coexist, so their coexistence is considered fatal if no version of any
# popular shell is known to exist that has both of the bugs in question.

# BUG_PARONEARG makes BUG_UPP workarounds impractical. I don't know any shell
# version that has both bugs, but test for it anyway, just to make sure.
case " $MSH_CAP " in
( *" BUG_UPP "* )
	case " $MSH_CAP " in
	( *" BUG_PARONEARG "* )
		_Msh_have FTL_UPPPARONE "This shell has both BUG_UPP and BUG_PARONEARG. This is not known to exist. Please report." ;;
	esac ;;
esac

# --- Tests for optional, non-standard, but common features. ---

# LEPIPEMAIN (execute Last Element of pipe in main shell)
# Most shells, when using a pipe construct such as:
#	command1 | command2 | command3
# execute each element of the pipe in its own subshell. This means any
# changes in variables done in 'command1', 'command2' and 'command3' are
# lost. But shells with LEPIPEMAIN, while still launching a subshell for
# 'command1' and 'command2', execute the last element of the pipe
# in the main shell. This means you can do something like:
#	somecommand | read VAR
# and have $VAR take effect in the main shell.
# Shells known to have LEPIPEMAIN are: zsh and AT&T ksh (not pdksh or mksh).
# Also, bash 4.2 and up with 'shopt -s lastpipe', but only if job control is
# disabled (set +m), which is usually the case for scripts only.
case ${BASH_VERSION+s} in
( s )	shopt -s lastpipe 2>/dev/null &&
	case $- in
	( *m* ) ;;
	( * )	_Msh_have LEPIPEMAIN ;;
	esac ;;
( * )	_Msh_test=''
	echo hi | read _Msh_test
	case ${_Msh_test} in
	( hi )	_Msh_have LEPIPEMAIN ;;
	esac ;;
esac

# Seed the $RANDOM pseudorandom number generator if we have it, otherwise
# reserve the variable name to prevent incompatible use. Test against the
# seed four times to make the chance of a false negative infinitesimal.
RANDOM=$$
case $RANDOM,$RANDOM,$RANDOM,$RANDOM in
( "$$,$$,$$,$$" )
	unset -v RANDOM
	readonly RANDOM ;;
( * )	_Msh_have RANDOM ;;
esac

# Test if we have $LINENO (current shell script line number).
# (Note: pdksh/oksh don't cope with making it read-only)
_Msh_test=${LINENO-}
: # need no-op for mksh to update LINENO before 'case'. [TODO? report bug?]
case ${_Msh_test} in
( "${LINENO-}" ) unset -v LINENO ;;
( * ) _Msh_have LINENO ;;
esac
#readonly LINENO

# LOCAL: Function-local variables using the 'local' or 'typeset' special
# builtin or shell keyword on functions defined using POSIX syntax().
if PATH=/dev/null; _Msh_testFn() { local _Msh_test || return; _Msh_test=7; } \
&& _Msh_test=42 && _Msh_testFn && PATH=${_Msh_PATH} && case ${_Msh_test} in (42);; (*) ! : ;; esac; then
	_Msh_have LOCAL
elif PATH=/dev/null; _Msh_testFn() { typeset _Msh_test || return; _Msh_test=7; } \
&& _Msh_test=42 && _Msh_testFn && PATH=${_Msh_PATH} && case ${_Msh_test} in (42);; (*) ! : ;; esac; then
	# alias it on pdksh/mksh -- and yash, if not in posix mode
	alias local=typeset
	_Msh_have LOCAL
fi 2>|/dev/null
PATH=${_Msh_PATH}

# KSH88FUNC: define ksh-style shell functions with the 'function' keyword,
# supporting local variables with the 'typeset' builtin. 
# KSH93FUNC: the same, but with static scoping for local variables.
# - NOTE: the superflous '()' must NOT be included; ksh93 doesn't accept it.
# - On AT&T ksh93, local variables are ONLY possible on functions defined
#   with the 'function' keyword and by using the 'typeset' builtin.
# This feature test was based on Q28 at http://kornshell.com/doc/faq.html
unset -f _Msh_testFn _Msh_testFn2 2>/dev/null	# BUG_FNSUBSH compat
case $(PATH=/dev/null; eval '
	function _Msh_testFn {
		_Msh_test2=${_Msh_test}
	}
	function _Msh_testFn2 {
		typeset _Msh_test=local
		_Msh_testFn
	}' &&
	_Msh_test=global &&
	_Msh_testFn2 &&
	echo "${_Msh_test2}") in
( global ) _Msh_have KSH93FUNC ;;
( local )  _Msh_have KSH88FUNC ;;
esac 2>|/dev/null

# ARITHPP: shell arith supports the ++ and -- unary operators.
# (Subshell needed because shells that don't support it exit.)
(	i=0
	: $((i++)) $((++i)) $((i--)) $((--i))
) 2>| /dev/null && _Msh_have ARITHPP

# ARITHCMD: standalone arithmetic evaluation using a command like
# ((expression)). The expression is evaluated using arithmetic as in
# standard $((expression)). If the value of the expression is non‐zero, the
# return status is 0; otherwise the return status is 1. This is exactly
# equivalent to 'let "expression"', but generally much faster.
# Supported by bash, zsh, AT&T ksh, and all pdksh variants.
_Msh_test=56
PATH=/dev/null
{ ((_Msh_test+=67)); } 2>| /dev/null
PATH=${_Msh_PATH}
case ${_Msh_test} in
( 123 )	_Msh_have ARITHCMD ;;
esac

# CESCQUOT: Quoting with C-style escapes, like $'\n' for newline.
case $'a\40b' in
( 'a b' ) _Msh_have CESCQUOT ;;
esac

# ADDASSIGN: Append a string to a variable using additive assignment VAR+=string
# TODO? rename to APPENDASSIGN, APPENDASGN?
_Msh_test=a
PATH=/dev/null
{ _Msh_test+=b; } 2>| /dev/null
PATH=${_Msh_PATH}
case ${_Msh_test} in
( ab )	_Msh_have ADDASSIGN ;;
esac

# PSREPLACE: Search and replace strings in variables using special parameter
# substitutions with a syntax vaguely resembling sed.
# Replace one: ${var/pattern/subst}  Replace all: ${var//pattern/subst}
# NOTE: prepending ${var/#/text} and appending ${var/%/text} are
# bash/zsh/mksh only and are not supported by AT&T ksh and yash.
# For compatibility, be sure to quote the '#' and '%'!
case $(	x=ABCDEFGHIJABCDEFG a=CDE b=QXY
	eval 'y=${x/"$a"/"$b"}; z=${x//"$a"/"$b"}' &&
	echo "$y,$z") in
	# Note: To keep busybox ash from exiting on a 'bad parameter substitution'
	#       syntax error, the feature test needs 'eval' *within* a subshell.
( ABQXYFGHIJABCDEFG,ABQXYFGHIJABQXYFG )
	_Msh_have PSREPLACE ;;
esac 2>|/dev/null

# ROFUNC: Set functions to read-only with 'readonly -f'. (bash, yash)
case $(_Msh_roFn() { echo RO; }; readonly -f _Msh_roFn; _Msh_roFn() { :; }; _Msh_roFn) in
( RO )	_Msh_have ROFUNC ;;
esac 2>/dev/null

# DOTARG: Dot scripts support arguments.
if [ -c /dev/stdin ] || [ -L /dev/stdin ]; then
	# The added [ -L /dev/stdin ] test is because, on Linux, if modernish
	# is sourced while stdin is redirected, e.g. by a here-document, then
	# /dev/stdin is a symlink to an already-unlinked temporary file. This
	# happens in install.sh.
	_Msh_test=
	command . /dev/stdin one two <<-'EOF' 2>/dev/null
	_Msh_test="$# ${1-} ${2-}"
	EOF
	case ${_Msh_test} in
	( '2 one two' )
		_Msh_have DOTARG ;;
	esac
else
	_Msh_have FTL_NODEVSTD 'No /dev/stdin'
fi

# --- End of tests ---
case ${_Msh_ftlcount} in
( 0 )	;;
( * )	case ${_Msh_ftlcount} in
	( 1 )	printf '1 fatal bug found. ' ;;
	( * )	printf '%d fatal bugs found. ' "${_Msh_ftlcount}" ;;
	esac 1>&2
	if [ -e "$HOME/.modernish-force" ]; then
		printf 'Proceeding anyway. THINGS WILL BREAK.\n'
	else
		printf "Sorry, this shell can't run modernish.\n"
		printf 'FYI, the full list of bugs, quirks and capabilities found is:\n%s\n' "$MSH_CAP"
		exit 127
	fi 1>&2 ;;
esac
case ${_Msh_IFS+s} in
( s )	IFS=${_Msh_IFS}; unset -v _Msh_IFS ;;
( * )	unset -v IFS ;;
esac
unset -f _Msh_testFn _Msh_testFn2 _Msh_have 2>/dev/null
unset -v _Msh_test _Msh_ftlcount

readonly MSH_CAP

# --- Control character constants ---

# POSIX does not have a good way to refer to control characters in variable
# assignments or as parameters to arbitrary commands. Let's make this
# convenient using readonly variables (constants) in the CC[01][0-9A-F] and
# CC[a-z] namespaces (CC = control character).
#
# We cannot have $CC00 because shell variables can't contain the 0 character.
case " $MSH_CAP " in
( *" CESCQUOT "* )
# If this shell has CESCQUOT, it's fast and easy (and redundant).
            CC01=$'\1'  CC02=$'\2'  CC03=$'\3'  CC04=$'\4'  CC05=$'\5'  CC06=$'\6'  CC07=$'\7'
CC08=$'\10' CC09=$'\11' CC0A=$'\12' CC0B=$'\13' CC0C=$'\14' CC0D=$'\15' CC0E=$'\16' CC0F=$'\17'
CC10=$'\20' CC11=$'\21' CC12=$'\22' CC13=$'\23' CC14=$'\24' CC15=$'\25' CC16=$'\26' CC17=$'\27'
CC18=$'\30' CC19=$'\31' CC1A=$'\32' CC1B=$'\33' CC1C=$'\34' CC1D=$'\35' CC1E=$'\36' CC1F=$'\37'
;;
( * )
# Shells without CESCQUOT are the reason we're doing this. We have to use
# trickery.
# CC0A (newline) needs to be initialized separately because it cannot be
# read using 'read' (it's always a separator). MAKE SURE THE FOLLOWING IS A
# LITERAL NEWLINE AND NOTHING ELSE.
CC0A='
'
# The initialization method below is optimized for speed; the
# straightforward way to do it would be --
#	CC01=$(printf '\1')
#	CC02=$(printf '\2')
#	...
#	CC1F=$(printf '\37')
# but launching a subshell 30 times would noticeably slow down initialization.
# The method below reads from a here-document filled using one subshell.
IFS=',' read CC01 CC02 CC03 CC04 CC05 CC06 CC07 \
	CC08 CC09      CC0B CC0C CC0D CC0E CC0F \
	CC10 CC11 CC12 CC13 CC14 CC15 CC16 CC17 \
	CC18 CC19 CC1A CC1B CC1C CC1D CC1E CC1F <<endofCC || exit 127
$(printf '\1,\2,\3,\4,\5,\6,\7,\10,\11,\13,\14,\15,\16,\17,\20,\21,\22,\23,\24,\25,\26,\27,\30,\31,\32,\33,\34,\35,\36,\37')
endofCC
;;
esac

# Make them constants.
readonly     CC01 CC02 CC03 CC04 CC05 CC06 CC07 \
	CC08 CC09 CC0A CC0B CC0C CC0D CC0E CC0F \
	CC10 CC11 CC12 CC13 CC14 CC15 CC16 CC17 \
	CC18 CC19 CC1A CC1B CC1C CC1D CC1E CC1F

# For convenience, provide some synonyms corresponding with 'printf' codes:
# e = escape; a = bell (alarm); b = backspace; f = form-feed; n = new-line;
# r = carriage return; t = tab; v = vertical tab
readonly "CCe=$CC1B" "CCa=$CC07" "CCb=$CC08" "CCf=$CC0C" "CCn=$CC0A" "CCr=$CC0D" "CCt=$CC09" "CCv=$CC0B"

# And these are handy to use in a glob pattern to check against control characters in a string:
#	if match "$var" "*[$CONTROLCHARS]*"; then
#		print "\$var contains at least one control character"
#	fi
# ...or for field splitting:
#	IFS="$WHITESPACE,/"  # split fields at any whitespace, comma or slash, with space a primary separator
# All the control characters:
readonly "CONTROLCHARS=$CC01$CC02$CC03$CC04$CC05$CC06$CC07$CC08$CC09$CC0A$CC0B$CC0C$CC0D$CC0E$CC0F$CC10$CC11$CC12$CC13$CC14$CC15$CC16$CC17$CC18$CC19$CC1A$CC1B$CC1C$CC1D$CC1E$CC1F"
# All whitespace characters (starts with a space):
readonly "WHITESPACE= $CCt$CCn$CCv$CCf$CCr"
# All the ASCII alphanumeric characters:
readonly "ASCIIALNUM=0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"
# Safelist for shell-quoting, good for use in bracket patterns. NOTES:
# - for BUG_BRACQUOT compatibility, the '-' must always be last, and ^ or ! never first!
# - for BUG_BRACSQBR compatibility, this cannot contain a ']'
readonly "SHELLSAFECHARS=${ASCIIALNUM}.,/:!@%^_+=-"

# -------------

# Internal functions. Subject to change without notice.

_Msh_dieArgs() {
	die "$1: incorrect number of arguments (was $2, must be $3)"
}

# -------------

# more readable synonym for '!'
alias not='! '

# test preceding command's success with 'if so;' or 'if not so;'
case " $MSH_CAP " in
( *' ARITHCMD '* )
	alias so='(($?==0))' ;;
( * )
	alias so='let "$?==0"' ;;
esac

# die: Emergency program halt for fatal errors.
# On non-interactive shells, terminate the entire program, including subshells.
# On interactive shells, we can't exit, so attempt to interrupt compound command
# execution, or if that fails, merely return. Hence the need for "|| return".
# Usage: die [ <message> ] || return
case $- in
( *i* )
	# On an interactive shell, attempt to interrupt command execution
	# (loops, compounds) and return straight to the prompt:
	# - An invalid output redirection on a special built-in (':') works on AT&T ksh, if it comes first.
	# - Invalid $((shell arith)) syntax works on bash, (d)ash, zsh (not AT&T ksh, mksh, yash).
	# Otherwise just return (mksh, yash); this is why we need '|| return' after every 'die' invocation.
	die() {
		case $# in
		( 0 )	;;
		( * )	echo "${ME##*/}:" "$@" 1>&2 ;;
		esac
		{	: >>/
			: $((\\))
		} 2>/dev/null
		return 125
	}
	;;
( * )
	# On a non-interactive shell, kill the program: send SIGTERM to main
	# process, and hope that terminates all its subshells as well. This
	# should allow terminating a program even from within a subshell.
	#
	# Using 'kill -s TERM 0' to kill the entire process groups is not
	# recommended because, if a modernish program is launched by another
	# shell program, the process group (0) sometimes (but not always; it
	# depends on the shell) includes the launching program, so not just the
	# current program is killed but the launching program as well!
	#
	# TODO: On recent bash and zsh, consider Stéphane Chazelas' method:
	#	http://unix.stackexchange.com/questions/48533/exit-shell-script-from-a-subshell#answer-48550
	#	Drawback: trap gets executed for each non-zero exit status.
	die() {
		case $# in
		( 0 )	;;
		( * )	echo "${ME##*/}:" "$@" 1>&2 ;;
		esac
		kill -s TERM "$$"
		command exit 125
	}
	;;
esac

# Extended 'exit'. Usage: exit [ -u ] [ <status> [ <message> ] ]
# (Be sure to still respect/restore IFS, etc. as exit traps may be executed after this!)
alias exit=_Msh_doExit
_Msh_doExit() {
	_Msh_exit_status=$?
	case ${1-} in
	( -u )	_Msh_exit_usage=y; shift ;;
	( * )	unset -v _Msh_exit_usage ;;
	esac
	case $# in
	( 0 )	;;
	( * )	case $1 in
		( [0123456789] | [123456789][0123456789] | 1[0123456789][0123456789] | 2[01234][0123456789] | 25[012345] )
			_Msh_exit_status=$1 ;;
		( * )	die "exit: bad exit status: $1" || \command exit ;;
		esac
		shift ;;
	esac
	case $# in
	( 0 )	;;
	( * )	echo "${ME##*/}: $@" 1>&2 ;;
	esac
	case ${_Msh_exit_usage+s} in
	( s )	showusage 1>&2 ;;
	esac
	command exit "${_Msh_exit_status}"
}

# Default showusage(). Feel free to override with another one.
showusage() {
	printf 'Type %s --help for help.\n' "${ME##*/}"
}

# Use a modernish module.
# If the module is already loaded, does nothing and exits successfully (status 0),
# preventing dependency loops.
# Global internal variable namespace: _Msh_using_*
# TODO? use -r: unload a module (it would need to provide an unuse function)
# TODO? use -f: force-reload a module
use() {
	ge "$#" 1 || _Msh_dieArgs use "$#" 'at least 1' || return

	# since we're using the module name as part of a variable name, we
	# must validate the input to avoid a code injection vulnerability
	case $1 in
	( '' | *[!${ASCIIALNUM}/]* )
		die "use: invalid module name: $1" || return ;;
	esac

	_Msh_use_M=$1
	shift

	# replace slashes by underscores for variable name
	_Msh_use_V=_Msh_using_${_Msh_use_M}
	while contains "${_Msh_use_V}" /; do
		_Msh_use_V=${_Msh_use_V%%/*}_${_Msh_use_V#*/}
	done

	# return gracefully if the module was already loaded
	isset "${_Msh_use_V}" && return

	[ -r "$MSH_PREFIX/libexec/modernish/${_Msh_use_M}.mm" ] || die "use: module ${_Msh_use_M} not found" || return

	case $# in
	( 0 )	_Msh_doUse ;;	# BUG_UPP workaround, BUG_PARONEARG compatible
	( * )	_Msh_doUse "$@" ;;
	esac || die "use: initialization of module '${_Msh_use_M}' failed" || return

	eval "${_Msh_use_V}=y"
	readonly "${_Msh_use_V}"  # TODO/BUG; in zsh, readonly always has function-local scope

	contains "$-" i && echo "Using ${_Msh_use_M}"

	unset -v _Msh_use_M _Msh_use_V
}
# At least one shell (FreeBSD /bin/sh) prioritises 'return' from a function
# over 'return' from a dot script. This would cause use() to be aborted if
# the dot script uses 'return', preventing proper handling of module
# initalization errors. To work around this, wrap the dot call in a function
# of its own.
# (Unfortunately, POSIX ambiguously specifies that "the 'return' utility
# shall cause the shell to stop executing the current function or dot
# script" without saying whether the deepest item in the call hierarchy
# should take priority or not.)
_Msh_doUse() {
	. "$MSH_PREFIX/libexec/modernish/${_Msh_use_M}.mm"
}

# -------------

# Test if all of the given words are shell keywords, regular or special
# built in commands, or (for words that are in all caps) optional
# capabilities or bugs that modernish found in the current shell.
#
# Usage: thisshellhas <word> [ <word> ... ]
#
# POSIX does not allow for a reliable way to find out what is a shell
# keyword or built in command, but it's essential for feature testing, so
# we have to make do with various shell-specific versions.
#
# TODO: support shell options, like 'thisshellhas -C' or 'thisshellhas -o noclobber'
# TODO: figure out some way to distinguish a builtin from a shell reserved
#       word that works even on minimal POSIX shells
if [ -n "${BASH_VERSION+s}" ] && PATH=/dev/null && command -v compgen
then
	PATH=${_Msh_PATH}
	# Version for bash (but not bash compiled with 'minimal configuration'). The
	# 'compgen' builtin easily lists all keywords (-k) and special/regular builtins
	# (-b). Store them in a cache variable so that subsequent invocations of
	# thisshellhas() don't require forking command substitution subshells.
	#
	# The LEPIPEMAIN capability (as of bash 4.2) needs to be tested for as a special
	# case, because bash only has this capability if 'shopt -s lastpipe' is active
	# *and* 'set -m' (job control) is *not* active, and either of those options may
	# be set or unset during the course of a program. The presence of this special
	# test is harmless on earlier versions of bash; it always returns false.
	readonly "_Msh_kwCache=$(compgen -kb)"
	thisshellhas() {
		case $# in
		( 0 )	_Msh_dieArgs thisshellhas "$#" 'at least 1' || return ;;
		esac
		while :; do
			case $1 in
			( '' | *[!\[\]\!{}"$SHELLSAFECHARS"]* )
				die "thisshellhas: invalid identifier: '$1'" || return ;;
			( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]* )
				case $CCn${_Msh_kwCache}$CCn in
				( *"$CCn$1$CCn"* ) ;;
				( * )	return 1 ;;
				esac
				;;
			( LEPIPEMAIN )
				case $- in
				( *m* )	return 1 ;;
				( * )	command shopt -p lastpipe >/dev/null 2>&1 || return 1 ;;
				esac
				;;
			( * )	case " $MSH_CAP " in
				( *" $1 "* )	;;
				( * )		return 1 ;;
				esac
				;;
			esac
			shift
			case $# in
			( 0 )	break ;;
			esac
		done
	}
elif [ -n "${BASH_VERSION+s}" ] && PATH=/dev/null && shopt -p lastpipe
then
	PATH=${_Msh_PATH}
	# Version for bash 4.2+ compiled with minimal configuration (or some other custom
	# config excluding 'compgen'). This is identical to the generic/default version at
	# the end, except for the special check for LEPIPEMAIN as explained above.
	_Msh_kwCache=
	thisshellhas() {
		case $# in
		( 0 )	_Msh_dieArgs thisshellhas "$#" 'at least 1' || return ;;
		esac
		while :; do
			case $1 in
			( '' | *[!\[\]\!{}"$SHELLSAFECHARS"]* )
				die "thisshellhas: invalid identifier: '$1'" || return ;;
			( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]* )
				case "${_Msh_kwCache} " in
				( *" $1 "* )	;;
				( *" !$1 "* )	return 1 ;;
				( * )	_Msh_kwCache="${_Msh_kwCache} $(
						unalias -- "$1" 2>/dev/null
						unset -f -- "$1"
						PATH=/dev/null
						command -v -- "$1" || { echo "!$1"; false; }
					)" || return 1 ;;
				esac
				;;
			( LEPIPEMAIN )
				case $- in
				( *m* )	return 1 ;;
				( * )	command shopt -p lastpipe >/dev/null 2>&1 || return 1 ;;
				esac
				;;
			( * )	case " $MSH_CAP " in
				( *" $1 "* )	;;
				( * )		return 1 ;;
				esac
				;;
			esac
			shift
			case $# in
			( 0 )	break ;;
			esac
		done
	}
elif [ -n "${ZSH_VERSION+s}" ] && PATH=/dev/null && enable -r
then
	PATH=${_Msh_PATH}
	# Version for zsh, using the same strategy as above. 'enable -r' prints all keywords
	# (reserved words), just 'enable' prints all special and regular builtins.
	readonly "_Msh_kwCache=$(enable -r; enable)"
	thisshellhas() {
		case $# in
		( 0 )	_Msh_dieArgs thisshellhas "$#" 'at least 1' || return ;;
		esac
		while :; do
			case $1 in
			( '' | *[!\[\]\!{}"$SHELLSAFECHARS"]* )
				die "thisshellhas: invalid identifier: '$1'" || return ;;
			( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]* )
				case $CCn${_Msh_kwCache}$CCn in
				( *"$CCn$1$CCn"* ) ;;
				( * )	return 1 ;;
				esac 2>/dev/null	# suppress huge trace if set -x
				;;
			( * )	case " $MSH_CAP " in
				( *" $1 "* )	;;
				( * )		return 1 ;;
				esac
			esac
			shift
			case $# in
			( 0 )	break ;;
			esac
		done
	}
elif [ -n "${YASH_VERSION+s}" ] && {
	[ -o posix ]
	case $? in
	( 0 )	set +o posix; PATH=/dev/null; command -vkb if && set -o posix || ! set -o posix ;;
	( 1 )	PATH=/dev/null; command -vkb if ;;
	( * )	false ;;
	esac
}; then
	PATH=${_Msh_PATH}
	# Version for yash. 'command -v --keyword --builtin-command' (-vkb)
	# does just what we want, but only if posix mode is off.
	thisshellhas() {
		case $# in
		( 0 )	_Msh_dieArgs thisshellhas "$#" 'at least 1' || return ;;
		esac
		while :; do
			case $1 in
			( '' | *[!\[\]\!{}"$SHELLSAFECHARS"]* )
				die "thisshellhas: invalid identifier: '$1'" || return;;
			( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]* )
				if [ -o posix ]; then
					set +o posix
					command -vkb -- "$1" || { set -o posix; return 1; }
					set -o posix
					# yash in POSIX mode checks builtins against $PATH, so recheck
					command -v "$1" || return 1
				else
					command -vkb -- "$1" || return 1
				fi >/dev/null
				;;
			( * )	case " $MSH_CAP " in
				( *" $1 "* )	;;
				( * )		return 1 ;;
				esac
				;;
			esac
			shift
			case $# in
			( 0 )	break ;;
			esac
		done
	}
elif case " $MSH_CAP " in
     ( *' BUG_FNSUBSH '* ) ;;
     ( * ) false ;;
     esac \
&& PATH=/dev/null && _Msh_test+='' && whence -a 'whence'
then
	PATH=${_Msh_PATH}
	# Version for ksh93.
	# BUG_FNSUBSH in ksh93 causes not just the setting but also the unsetting of functions and aliases
	# within subshells to be silently ignored for functions or aliases that are inherited from the main
	# shell. That makes it impossible to use our default technique of using 'unset -f' and 'unalias'
	# within a subshell to find a shell keyword or builtin.
	# The 'builtin' command lists all the normal and special builtin commands, so we can at least cache
	# those, but there is no way to list shell keywords. To find a shell keyword, use a hack: try to
	# define the word as a function within a subshell and see if it generates a syntax error.
	_Msh_kwCache=$(builtin)
	thisshellhas() {
		case $# in
		( 0 )	_Msh_dieArgs thisshellhas "$#" 'at least 1' || return ;;
		esac
		while :; do
			case $1 in
			( '' | *[!\[\]\!{}"$SHELLSAFECHARS"]* )
				die "thisshellhas: invalid identifier: '$1'" || return ;;
			( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]* )
				case "$CCn${_Msh_kwCache}$CCn" in
				( *"$CCn$1$CCn"* )
					;;
				( *"$CCn!$1$CCn"* )
					return 1 ;;
				( * )	if ( eval "$1() { :; }" ); then
						_Msh_kwCache+="$CCn!$1"
						return 1
					else
						_Msh_kwCache+="$CCn$1"
					fi 2>/dev/null ;;
				esac
				;;
			( * )	case " $MSH_CAP " in
				( *" $1 "* )	;;
				( * )		return 1 ;;
				esac
				;;
			esac
			shift
			case $# in
			( 0 )	break ;;
			esac
		done
	}
elif case " $MSH_CAP " in
     ( *' BUG_CMDVRESV '* ) ;;
     ( * ) false ;;
     esac \
&& PATH=/dev/null && whence 'if'
then
	PATH=${_Msh_PATH}
	# Version for pdksh/mksh. It has BUG_CMDVRESV so "command -v" command does not
	# find reserved words such as "if" (or "select"), contrary to POSIX.
	# Ref: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/command.html#tag_20_22
	# So we use its variant of the 'whence' builtin, which does find
	# them. Thankfully it does not have BUG_FNSUBSH so we can otherwise
	# use the same technique as the default version below.
	# mksh fixes this bug (so won't use this version) as of R51 2015/07/10.
	_Msh_kwCache=
	thisshellhas() {
		case $# in
		( 0 )	_Msh_dieArgs thisshellhas "$#" 'at least 1' || return ;;
		esac
		while :; do
			case $1 in
			( '' | *[!\[\]\!{}"$SHELLSAFECHARS"]* )
				die "thisshellhas: invalid identifier: '$1'" || return ;;
			( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]* )
				case "${_Msh_kwCache} " in
				( *" $1 "* )	;;
				( *" !$1 "* )	return 1 ;;
				( * )	_Msh_kwCache="${_Msh_kwCache} $(
						unalias -- "$1" 2>/dev/null
						unset -f -- "$1" 2>/dev/null
						PATH=/dev/null
						whence -- "$1" || { echo "!$1"; false; }
					)" || return 1 ;;
				esac
				;;
			( * )	case " $MSH_CAP " in
				( *" $1 "* )	;;
				( * )		return 1 ;;
				esac
				;;
			esac
			shift
			case $# in
			( 0 )	break ;;
			esac
		done
	}
else
	PATH=${_Msh_PATH}
	# Generic/default version. As far as I know, this version works on all other
	# shells; at least dash, Busybox ash, FreeBSD /bin/sh. (POSIX is not supposed to
	# find regular builtins after setting PATH to /dev/null, so be sure to restore
	# PATH before running 'echo' or 'false'. yash in strict POSIX mode is the only
	# shell known to pay attention to that rule, and it's got its own version above.)
	_Msh_kwCache=
	thisshellhas() {
		case $# in
		( 0 )	_Msh_dieArgs thisshellhas "$#" 'at least 1' || return ;;
		esac
		while :; do
			case $1 in
			( '' | *[!\[\]\!{}"$SHELLSAFECHARS"]* )
				die "thisshellhas: invalid identifier: '$1'" || return ;;
			( *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789_]* )
				case "${_Msh_kwCache} " in
				( *" $1 "* )	;;
				( *" !$1 "* )	return 1 ;;
				( * )	_Msh_kwCache="${_Msh_kwCache} $(
						unalias -- "$1" 2>/dev/null
						unset -f -- "$1" 2>/dev/null
						PATH=/dev/null
						command -v -- "$1" || { echo "!$1"; false; }
					)" || return 1 ;;
				esac
				;;
			( * )	case " $MSH_CAP " in
				( *" $1 "* )	;;
				( * )		return 1 ;;
				esac
				;;
			esac
			shift
			case $# in
			( 0 )	break ;;
			esac
		done
	}
fi >/dev/null 2>&1

# Try a POSIX reserved word, POSIX special builtin, and POSIX regular builtin.
if ! thisshellhas 'while' 'set' 'wait'; then
	printf "Failed to determine a working thisshellhas() function. " 1>&2
	if [ -e "$HOME/.modernish-force" ]; then
		printf "Proceeding anyway. Feature testing won't work right.\n" 1>&2
	else
		printf "Can't run modernish.\n" 1>&2
		exit 127
	fi
fi

# builtin: Run a shell built-in command. Most shells come with 'builtin'
# built-in, but here it is for the rest: (d)ash and yash. This is written to
# mimic 'builtin' on bash, *ksh and zsh as closely as possible.
#
# One snag: since this is a shell function, it will not work for manipulating
# the positional parameters, because they are local to the function. For
# instance, 'builtin set -- some stuff' will not work, nor will 'builtin shift'.
#
# BUG: Can't distinguish builtin from shell reserved word, so 'builtin if'
# will search for an external command 'if'. TODO: create test for resv. word
if ! thisshellhas builtin; then
	builtin() {
		case $# in
		( 0 )	return ;;
		esac
		if thisshellhas "$1"; then
			command "$@"
		else
			echo "builtin: not a shell builtin: $1" 1>&2
			return 1
		fi
	}
fi

# extern: Run an external command without having to know its exact location,
# even if a built-in command, alias or shell function by that name exists.
if thisshellhas [[; then
	# Use [[ to avoid [ bugs, particularly on zsh
	extern() {
		case $# in
		( 0 )	_Msh_dieArgs extern $# 'at least 1' || return ;;
		esac
		isset IFS && _Msh_ext_ifs=$IFS || unset -v _Msh_ext_ifs
		unset -v _Msh_ext_r
		IFS=:	# split at ':' for $PATH
		for _Msh_ext_d in $PATH; do
			if [[ -f ${_Msh_ext_d}/$1 && -x ${_Msh_ext_d}/$1 ]]; then
				"${_Msh_ext_d}/$@"
				_Msh_ext_r=$?
				break
			fi
		done
		unset -v _Msh_ext_d
		case ${_Msh_ext_ifs+s} in
		( s )	IFS=${_Msh_ext_ifs}; unset -v _Msh_ext_ifs ;;
		( * )	unset -v IFS ;;
		esac
		case ${_Msh_ext_r+s} in
		( s )	eval "unset -v _Msh_ext_r; return ${_Msh_ext_r}"  ;;
		( * )	echo "extern: command not found: $1" 1>&2; return 127 ;;
		esac
	}
else
	extern() {
		case $# in
		( 0 )	_Msh_dieArgs extern $# 'at least 1' || return ;;
		esac
		isset IFS && _Msh_ext_ifs=$IFS || unset -v _Msh_ext_ifs
		unset -v _Msh_ext_r
		IFS=:	# split at ':' for $PATH
		for _Msh_ext_d in $PATH; do
			if [ -f "${_Msh_ext_d}/$1" ] && [ -x "${_Msh_ext_d}/$1" ]; then
				"${_Msh_ext_d}/$@"
				_Msh_ext_r=$?
				break
			fi
		done
		unset -v _Msh_ext_d
		case ${_Msh_ext_ifs+s} in
		( s )	IFS=${_Msh_ext_ifs}; unset -v _Msh_ext_ifs ;;
		( * )	unset -v IFS ;;
		esac
		case ${_Msh_ext_r+s} in
		( s )	eval "unset -v _Msh_ext_r; return ${_Msh_ext_r}"  ;;
		( * )	echo "extern: command not found: $1" 1>&2; return 127 ;;
		esac
	}
fi

# -------------

# Test if argument is valid portable variable (or shell function) name.
# Deals with empty removal. (This is why it doesn't take more than one argument.)
isvarname() {
	case ${#},${1-} in
	( [!01],* | ?[!,]* )
		_Msh_dieArgs isvarname "$#" '0 or 1' ;;
	( [01], | 1,[0123456789]* | 1,*[!${ASCIIALNUM}_]* )
		return 1 ;;
	esac
}

# Check if a variable is set, a.k.a. declared
# (which is different from it being empty).
# Usage: isset <varname>
# TODO: add 'isset -o' to check if a shell option is set
# TODO: deal with arrays; bash and ksh require different
#       voodoo to check if arrays are set
if thisshellhas [[; then
	if ( eval '[[ -v MSH_VERSION ]]' ) 2>/dev/null; then
		# Version for '[[ -v' in bash 4.2+ and AT&T ksh 2012-08-01.
		# Use 'eval' to avoid syntax errors in shells with '[[' but without '[[ -v'.
		if thisshellhas BUG_IFSISSET; then
			# Workaround version for BUG_IFSISSET in recent AT&T ksh93. For
			# some reason they've made it impossible to distinguish in any
			# normal way between empty IFS and unset IFS. But this applies
			# only to IFS and no other variable, so we can figure it out by
			# analysing field splitting behaviour. No field splitting means
			# empty IFS and default field splitting means unset IFS.
			eval 'isset() {
				case ${#},${1-} in
				( 1, | 1,[0123456789]* | 1,*[!${ASCIIALNUM}_]* )
					die "isset: invalid variable name: $1" || return ;;
				( 1,IFS )
					case ${IFS:+n} in		# non-empty: it is set
					( "" )	set -- "a b"		# empty: test for default field splitting
						set -- $1
						[[ $# -eq 1 ]]		# no field splitting: it is empty and set
					esac ;;
				( 1,* )	[[ -v $1 ]] ;;
				( * )	_Msh_dieArgs isset "$#" 1 || return ;;
				esac
			}'
		else
			eval 'isset() {
				case ${#},${1-} in
				( 1, | 1,[0123456789]* | 1,*[!${ASCIIALNUM}_]* )
					die "isset: invalid variable name: $1" || return ;;
				( 1,* )	[[ -v $1 ]] ;;
				( * )	_Msh_dieArgs isset "$#" 1 || return ;;
				esac
			}'
		fi
	else
		# version for [[ without -v
		isset() {
			case ${#},${1-} in
			( 1, | 1,[0123456789]* | 1,*[!${ASCIIALNUM}_]* )
				die "isset: invalid variable name: $1" || return ;;
			( 1,* )	eval "[[ -n \${$1+s} ]]" ;;
			( * )	_Msh_dieArgs isset "$#" 1 || return ;;
			esac
		}
	fi
else
	if thisshellhas BUG_IFSISSET; then
		printf '%s\n' "You're on a shell with BUG_IFSISSET but without 'test -v'!" \
			"This is not known to exist, so workaround not implemented. Please report." 1>&2
		exit 127
	fi
	# default (POSIX) version
	isset() {
		case ${#},${1-} in
		( 1, | 1,[0123456789]* | 1,*[!${ASCIIALNUM}_]* )
			die "isset: invalid variable name: $1" || return ;;
		( 1,* )	eval "case \${$1+s} in ( '' ) return 1 ;; esac" ;;
		( * )	_Msh_dieArgs isset "$#" 1 || return ;;
		esac
	}
fi

# unexport: the opposite of export.
# Clear the 'export' bit of a variable, conserving its value, or assign
# variables without the export bit even if 'set -a' (allexport) is active.
# This allows an "export all variables, except these" way of working. Unlike
# 'export', 'unexport' does not (and cannot) work for read-only variables.
# Usage: like 'export'. (However, unlike 'export' in some shells, there
# is no protection against field splitting or pathname expansion! But
# with 'export' you can't rely on that anyway if you work cross-platform.
# So appropriate shell-quoting is necessary if you pass an assignment.)
#
if [ -n "${YASH_VERSION+s}" ] && typeset --unexport _Msh_test; then
	# yash is the only shell I know of with a straightforward way of doing this.
	# (Just to be sure, let's not use the short option equivalent 'typeset -X'
	# as it has a very different meaning on recent versions of ksh93!)
	# Still do validation, because yash's 'typeset' silently ignores crazy stuff.
	unexport() {
		case $# in
		( 0 )	_Msh_dieArgs unexport "$#" 'at least 1' || return ;;
		esac
		typeset _Msh_V	# local
		for _Msh_V do
			isvarname "${_Msh_V%%=*}" || die "unexport: invalid variable name: ${_Msh_V%%=*}" || return
		done
		typeset --global --unexport "$@" || die "unexport: 'typeset' failed"
	}
else
	# All other shells have to use trickery: make sure 'set -a' is off,
	# then unset the variable, then assign or restore its value, then
	# restore the previous status of 'set -a'.
	unexport() {
		case ${#}${-} in	# BUG_HASHVAR workaround: '${#}'
		( 0* )	_Msh_dieArgs unexport "$#" 'at least 1' || return ;;
		( *a* )	_Msh_nE_a=y; set +a ;;
		( * )	_Msh_nE_a='' ;;
		esac
		for _Msh_nE_V do
			isvarname "${_Msh_nE_V%%=*}" || break
			case ${_Msh_nE_V} in
			( *=* )	unset -v "${_Msh_nE_V%%=*}"
				eval "${_Msh_nE_V%%=*}=\${_Msh_nE_V#*=}"
				;;
			( * )	if isset "${_Msh_nE_V}"; then
					eval "_Msh_nE_val=\${${_Msh_nE_V}}"
					unset -v "${_Msh_nE_V}"
					eval "${_Msh_nE_V}=\${_Msh_nE_val}"
				fi
				;;
			esac
			_Msh_nE_V=''
		done
		case ${_Msh_nE_a} in
		( y )	set -a ;;
		esac
		case ${_Msh_nE_V} in
		( ?* )	die "unexport: invalid variable name: ${_Msh_nE_V%%=*}" || return ;;
		esac
		unset -v _Msh_nE_V _Msh_nE_val _Msh_nE_a || :  # BUG_UNSETFAIL workaround
	}
fi 2>/dev/null

# -------------

# Shell-quote the values of one or more variables to prepare them for
# safe use with "eval" or other parsing by the shell. If a value only
# contains shell-safe characters, it leaves it unquoted. Empty values
# are quoted.
#
# Usage: shellquote [ <options> ] <varname> ... [ [ <options> ] <varname> ... ]
#
# Options take effect for all variable names following them. Each option
# must be a separate argument.
# -f	Force quoting, even if value only contains shell-safe characters.
#	This is useful for e.g. producing string literals for glob patterns
#	or regular expressions.
# +f	Don't quote if value only contains shell-safe characters. (Default)
# -n N	(N>=1): Multiple quoting levels: quote N times. (Default: 1)
#
# Returns success (0) if all variables were processed successfully, and
# non-success (1) if any undefined (unset) variables were encountered. Unset
# variables are left alone. It continues even after encountering an unset
# variable.
#
# Inspired by "Rich's sh (POSIX shell) tricks":
# http://www.etalabs.net/sh_tricks.html
# under "Shell-quoting arbitrary strings":
# quote () { printf %s\\n "$1" | sed "s/'/'\\\\''/g;1s/^/'/;\$s/\$/'/" ; }
# Rich uses a command substitution with "sed" for this, launching two
# processes for each value to quote. The "shellquote" function does the same
# thing, but in-place. As it doesn't launch any subshells or external
# processes, it's more than 10 times faster (on bash, only 5-ish times).
#
# TODO?
# - option for reading stdin, producing quoted output?
# - option for quoting values rather than variables?
# - option for output to stdout instead of setting variable?
#
# TODO:
# - use printf %q in bash, zsh and AT&T ksh
# - BUG: if variable is readonly, shell exits/aborts, so IFS/globbing is not
#        restored on interactive shell. But testing readonly needs a
#        subshell: performance hit. What to do?
shellquote() {
	case $# in ( 0 ) _Msh_dieArgs quote "$#" 'at least 1' || return ;; esac

	# save and set internal field separator
	isset IFS && _Msh_qV_IFS=$IFS || unset -v _Msh_qV_IFS
	IFS=\'

	# save globbing state; turn off globbing
	case $- in
	( *f* )	_Msh_qV_glob='' ;;
	( * )	set -f; _Msh_qV_glob='set +f;' ;;
	esac

	_Msh_qV_ERR=0
	_Msh_qV_f=''
	_Msh_qV_n=1
	_Msh_qV_N=''
	for _Msh_qV_N do
		case ${_Msh_qV_n} in
		( '' )	_Msh_qV_N=-n${_Msh_qV_N}; _Msh_qV_ERR=0 ;;
		esac
		case ${_Msh_qV_N} in
		( -f )	_Msh_qV_f=y; continue ;;
		( +f )	_Msh_qV_f=''; continue ;;
		( -n )	_Msh_qV_n=''; _Msh_qV_ERR=2; continue ;;
		( -n* )	_Msh_qV_n=${_Msh_qV_N#-n}
			if ! isint "${_Msh_qV_n}" || lt _Msh_qV_n 1; then
				_Msh_qV_ERR=3
				break
			fi
			continue ;;
		( '' | [0123456789]* | *[!${ASCIIALNUM}_]* )
			_Msh_qV_ERR=2
			break ;;
		esac

		if ! isset "${_Msh_qV_N}"; then
			_Msh_qV_ERR=1
			continue
		fi

		eval "_Msh_qV_VAL=\${${_Msh_qV_N}}"

		_Msh_qV_i=${_Msh_qV_n}
		while let "(_Msh_qV_i-=1) >= 0"; do

#			if let "${#_Msh_qV_VAL}>16384"
#			then
#				# The number and size grows exponentially with quoting levels; doing parameter substitution on
#				# big variables with 1000s of quotes can lock up the shell, so fall back to 'sed' if excessive.
#				# However, this quoting algorithm is more primitive, so the growth exponent is higher.
#				_Msh_qV_VAL=$(printf '%s\n' "${_Msh_qV_VAL}" | sed "s/'/'\\\\''/g; 1 s/^/'/; \$ s/\$/'/")
#				continue
#			fi

			case ${_Msh_qV_VAL} in

			# Quote empties.
			( '' )
				_Msh_qV_VAL=\'\'
				;;

			# If it's not safe for unescaped double-quoting, unescaped single-quoting or
			# not quoting, then use a mixture of single-quoting and backslash-escaping to
			# mitigate exponential growth with multiple levels of quoting.
			# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_02
			( *\'* )
				case ${_Msh_qV_VAL} in
				( *[\"\$\`\\]* )
					# Split the value of the specified variable at its single quote characters (if
					# any), storing the parts into the positional parameters. Add a protector character
					# 'X' at the end so a final literal single quote is counted.
					set -- ${_Msh_qV_VAL}X

					# First part: backslash-escape any existing initial quotes; add the initial quote.
					_Msh_qV_VAL=''
					while let "$# > 0 && ${#1} == 0"; do
						_Msh_qV_VAL="${_Msh_qV_VAL}\\'"
						shift
					done
					_Msh_qV_VAL="${_Msh_qV_VAL}'${1}"
					shift

					# Second to last parts: escape existing single quotes.
					while let "$# > 0"; do
						# Add closing quote.
						_Msh_qV_VAL="${_Msh_qV_VAL}'"
						# Backslash-escape any existing intermediary quotes.
						while let "$# > 0 && ${#1} == 0"; do
							_Msh_qV_VAL="${_Msh_qV_VAL}\\'"
							shift
						done
						# Add the escaped single quote plus an opening quote before the next part.
						_Msh_qV_VAL="${_Msh_qV_VAL}\\''${1}"
						shift
					done

					# Remove the protector character. Either prevent a final pair
					# of empty single quotes, or add the final single quote.
					case ${_Msh_qV_VAL} in
					( *\'X )	_Msh_qV_VAL="${_Msh_qV_VAL%\'X}" ;;
					( *X )		_Msh_qV_VAL="${_Msh_qV_VAL%X}'" ;;
					( * )		_Msh_qV_ERR=99; break ;;
					esac
					;;
				( * )
					# Safe for unescaped double quoting.
					_Msh_qV_VAL=\"${_Msh_qV_VAL}\"
					;;
				esac
				;;

			# Not safe for double quoting, but does not contain a single quote:
			# do simple single quoting without escaping anything.
			( *[\"\$\`\\]* )
				_Msh_qV_VAL=\'${_Msh_qV_VAL}\'
				;;

			# If it's safe to double-quote without escaping anything, do so. (A mixed quoting
			# strategy slightly mitigates exponential growth with multiple quoting levels.)
			# Ref.: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_02_03
			( *[!"${SHELLSAFECHARS}"]* )
				_Msh_qV_VAL=\"${_Msh_qV_VAL}\"
				;;

			# Shell-safe chars only: only quote if -f was given.
			( * )
				case ${_Msh_qV_f:+f} in
				( f )	_Msh_qV_VAL=\'${_Msh_qV_VAL}\' ;;
				( * )	_Msh_qV_i=0 ;;	# avoid pointless iterations if option '-n' > 1
				esac
				;;

			esac
		done

		# Replace the value of the specified variable with its quoted value.
		eval "${_Msh_qV_N}=\${_Msh_qV_VAL}"
	done

	case ${_Msh_qV_IFS+s} in
	( s )	IFS=${_Msh_qV_IFS}
		unset -v _Msh_qV_IFS ;;
	( * )	unset -v IFS ;;
	esac
	eval "${_Msh_qV_glob}"
	case ${_Msh_qV_N} in
	( '' | [+-]f | -n?* ) _Msh_qV_ERR=4 ;;
	esac
	unset -v _Msh_qV_VAL _Msh_qV_glob _Msh_qV_f _Msh_qV_n _Msh_qV_i
	case ${_Msh_qV_ERR} in
	( 2 )	die "shellquote: invalid option or variable name: ${_Msh_qV_N}" ;;
	( 3 )	die "shellquote: -n: integer >= 1 expected, got '${_Msh_qV_N#-n}'" ;;
	( 4 )	die "shellquote: expected variable(s) to quote" ;;
	( 99 )	die "shellquote: internal error" ;;
	esac
	eval "unset -v _Msh_qV_N _Msh_qV_ERR; return ${_Msh_qV_ERR}"
}

# Shell-quote all the positional parameters in-place.
# Usage: shellquoteparams (no arguments)
# To unquote them again, do:  eval set -- "$@"
if thisshellhas ADDASSIGN; then
	_Msh_doShellQuoteParams() {
		_Msh_sQP_P=''
		for _Msh_sQP_p do
			shellquote -n2 _Msh_sQP_p || die "shellquoteparams: shellquote failed" || return
			_Msh_sQP_P+="${_Msh_sQP_p} "
		done
	}
else
	_Msh_doShellQuoteParams() {
		_Msh_sQP_P=''
		for _Msh_sQP_p do
			shellquote -n2 _Msh_sQP_p || die "shellquoteparams: shellquote failed" || return
			_Msh_sQP_P="${_Msh_sQP_P}${_Msh_sQP_p} "
		done
	}
fi
alias shellquoteparams='{ gt "$#" 0 && _Msh_doShellQuoteParams "$@" && eval "set -- ${_Msh_sQP_P}" && unset -v _Msh_sQP_P; }'

# Shell-quote and store (a subrange of) the current positional parameters
# into a variable. To restore them later, it is safe to do:
#	eval "set -- $varname"
# (with double quotes and non-escaped $).
# Usage: storeparams [ -f <firstparam> ] [ -t <lastparam> ] <varname>
#	 (f = from, t = to)
# NOTE: functions set by harden() call _Msh_doStoreParams() directly.
if thisshellhas BUG_UPP; then
	alias storeparams='_Msh_doStoreParams "$#" ${1+"$@"}'
else
	alias storeparams='_Msh_doStoreParams "$#" "$@"'
fi
_Msh_doStoreParams() {
	_Msh_sP_f=1
	_Msh_sP_t=$1
	_Msh_sP_i=$(( $1 + 1 ))
	while	let "$# >= (_Msh_sP_i+=1)" &&
		eval "startswith \"\${${_Msh_sP_i}}\" '-' && _Msh_sP_o=\${${_Msh_sP_i}#-}"
	do
		case ${_Msh_sP_o} in
		( - )	let "_Msh_sP_i+=1"
			break ;;
		( f )	let "$# >= (_Msh_sP_i+=1)" || die "storeparams: -f: option requires an argument" || return
			eval "_Msh_sP_f=\${${_Msh_sP_i}}" ;;
		( f* )	_Msh_sP_f=${_Msh_sP_o#f} ;;
		( t )	let "$# >= (_Msh_sP_i+=1)" || die "storeparams: -t: option requires an argument" || return
			eval "_Msh_sP_t=\${${_Msh_sP_i}}" ;;
		( t* )	_Msh_sP_t=${_Msh_sP_o#t} ;;
		esac
	done
	let "$# == _Msh_sP_i" || die "storeparams: 1 non-option argument expected, got $(($# - _Msh_sP_i + 1))" || return
	eval "_Msh_sP_V=\${${_Msh_sP_i}}"
	isvarname "${_Msh_sP_V}" || die "storeparams: invalid variable name: ${_Msh_sP_V}" || return
	isint "${_Msh_sP_f}" && let "_Msh_sP_f >= 1" || die "storeparams: -f: invalid value: '${_Msh_sP_f}'" || return
	isint "${_Msh_sP_t}" || die "storeparams: -t: invalid value: '${_Msh_sP_t}'" || return
	let "_Msh_sP_t > $#" && _Msh_sP_t=$#
	_Msh_sP_PPs=''
	shift "${_Msh_sP_f}"
	_Msh_sP_i=$((_Msh_sP_f-1))
	while let "(_Msh_sP_i+=1) <= _Msh_sP_t"; do
		_Msh_sP_P=$1
		shellquote _Msh_sP_P || die "storeparams: 'shellquote' failed" || return
		_Msh_sP_PPs=${_Msh_sP_PPs:+${_Msh_sP_PPs} }${_Msh_sP_P}
		shift
	done
	eval "${_Msh_sP_V}=\${_Msh_sP_PPs}"
	unset -v _Msh_sP_f _Msh_sP_t _Msh_sP_o _Msh_sP_V _Msh_sP_i _Msh_sP_P _Msh_sP_PPs || :  # BUG_UNSETFAIL compat
}

# ----------------

# Stack functions.
# Every variable has its own stack: simply do push VAR and pop VAR.
# Also works for saving/restoring shell options, e.g.: push -f; pop -f
# Uses global variable namespace: _Msh__V*__S*
#
# Features:
#	- Saves and restores not just value, but set/unset state.
#	- Stack size is limited by memory or shell constraints only.
#	- Fast: does not launch any subshell or external process.
#	- Cleans up after itself: leaves no trace in the environment upon
#         empty stack.
#
# Use cases:
#	- Easily store lots of arbitary data to use later.
#	- Code blocks (not just functions) with 'fake' local variables.
#	- Easy temporary field splitting ('push IFS' and 'pop IFS' work fine).

# Push each variable's value or shell option setting on its respective stack.
# Usage: push <item> [ <item> ...]
#	where <item> is a variable name or shell option (dash plus letter).
push() {
	# Exporting the stack would be bad; run 'push' without 'set -a' active.
	# Save the status of 'set -a' in a variable so 'push -a' works.
	case ${#},$- in
	( 0,* )	_Msh_dieArgs push "$#" 'at least 1' || return ;;
	( *a* )	set +a; _Msh_push_opta=y ;;
	( * )	unset -v _Msh_push_opta ;;
	esac

	# Validate variable names before doing anything. Portable shell varname
	# constraints apply; also disallow internal separators __V and __S.
	_Msh_push_err=0
	for _Msh_push_V do
		case ${_Msh_push_V} in
		( -[abcdfghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] ) ;;	# short-form shell option: ok (no 'e' or 'o')
		( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
			die "push: invalid variable name or shell option: ${_Msh_push_V}" || { _Msh_push_err=$?; break; } ;;
		esac
	done

	# Do the job.
	case ${_Msh_push_err} in
	( 0 ) for _Msh_push_V do
		# If it's a (short, single) shell option, translate to internal variable.
		case ${_Msh_push_V} in
		( -a )	case ${_Msh_push_opta+s} in
			( s )	_Msh_ShellOpt_a='' ;;
			( * )	unset -v _Msh_ShellOpt_a ;;
			esac
			_Msh_push_V='_Msh_ShellOpt_a'
			;;
		( -? )	_Msh_push_V=${_Msh_push_V#-}
			case $- in
			( *${_Msh_push_V}* )
				eval "_Msh_ShellOpt_${_Msh_push_V}=''" ;;
			( * )	unset -v "_Msh_ShellOpt_${_Msh_push_V}" ;;
			esac
			_Msh_push_V="_Msh_ShellOpt_${_Msh_push_V}"
			;;
		esac

		# Initialize/validate stack pointer.
		eval "_Msh_push_SP=\${_Msh__V${_Msh_push_V}__SP=0}"
		case ${_Msh_push_SP} in
		( '' | *[!0123456789]* ) die "push: Stack pointer for ${_Msh_push_V} corrupted" || return  ;;
		esac

		# Store value or unset status.
		if isset "${_Msh_push_V}"; then
			eval "_Msh__V${_Msh_push_V}__S${_Msh_push_SP}=\$${_Msh_push_V}"
		else
			unset -v "_Msh__V${_Msh_push_V}__S${_Msh_push_SP}"
		fi

		# Increase stack pointer for next item on stack.
		: $((_Msh__V${_Msh_push_V}__SP = _Msh_push_SP + 1))
	done;; esac
	case ${_Msh_push_opta+s} in
	( s )	set -a; unset -v _Msh_push_opta ;;
	esac
	eval "unset -v _Msh_push_V _Msh_push_SP _Msh_push_err; return ${_Msh_push_err}"
}

# Pop each variable's last value off the stack and restore it into the
# variable.
#
# Returns unsuccessfully without changing anything if *any* of the stacks
# for the specified variables or shell options is empty. Either all get
# popped, or none. This helps provide validation against stack inconsistency
# for groups of variables that should be pushed/popped together.
#
# Usage: pop <item> [ <item> ...]
#	 where <item> is a variable name or shell option (dash plus letter).
if thisshellhas BUG_ARITHTYPE; then
	# BUG_ARITHTYPE (zsh) compatible version: first unset the variable
	# before popping it, in case it acquired an arithmetic type restriction
	# and the value to pop is not arithmetic.
	# This workaround version can't be used for all shells, because on some
	# shells, certain variables may not tolerate being unset at all. One
	# known instance of this is that, on (d)ash and derivatives, OPTIND (the
	# index variable for 'getopts') cannot be unset, and the shell exits if
	# you try! So using this version would kill 'pop OPTIND' on (d)ash.
	# (Thankfully, zsh does not seem intolerant of unsetting any variable.)
	pop() {
		# Exporting the stack would be bad; run 'pop' without 'set -a' active.
		# Save the status of 'set -a' in a variable so 'pop -a' works.
		case ${#},$- in
		( 0,* )	_Msh_dieArgs pop "$#" 'at least 1' || return ;;
		( *a* )	set +a; _Msh_pop_opta=y ;;
		( * )	unset -v _Msh_pop_opta ;;
		esac

		# Validate everything before doing anything.
		_Msh_pop_err=0
		for _Msh_pop_V do
			case ${_Msh_pop_V} in
			( -[abcdfghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )	# short-form shell option (no 'e' or 'o')
				_Msh_pop_V="_Msh_ShellOpt_${_Msh_pop_V#-}" ;;
			( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
				die "pop: invalid variable name or shell option: $_Msh_pop_V" || { _Msh_pop_err=$?; break; } ;;
			esac

			if isset "_Msh__V${_Msh_pop_V}__SP"; then
				# validate stack pointer
				eval "_Msh_pop_SP=\${_Msh__V${_Msh_pop_V}__SP}"
				case ${_Msh_pop_SP} in
				( '' | 0* | *[!0123456789]* )
					die "pop: Stack pointer for ${_Msh_pop_V} corrupted" || { _Msh_pop_err=$?; break; } ;;
				esac
			else
				# stack empty
				_Msh_pop_err=1
			fi
		done

		# Do the job.
		case ${_Msh_pop_err} in
		( 0 ) for _Msh_pop_V do
			# If shell option, translate to internal variable.
			case ${_Msh_pop_V} in
			( -? )	_Msh_pop_V="_Msh_ShellOpt_${_Msh_pop_V#-}" ;;
			esac

			# Decrease stack pointer so it points to the item to pop.
			: $(( _Msh_pop_SP = ( _Msh__V${_Msh_pop_V}__SP -= 1 ) ))

			# Restore value or unset status.
			unset -v "${_Msh_pop_V}"	# BUG_ARITHTYPE compat: first unset
			if isset "_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}"; then
				eval "${_Msh_pop_V}=\${_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}}"
			fi

			# Clean up: unset the stack variable we just popped off the stack.
			unset -v "_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}"

			# Clean up: if the stack is empty, unset the stack pointer.
			case ${_Msh_pop_SP} in
			( 0 )	unset -v "_Msh__V${_Msh_pop_V}__SP" ;;
			esac

			# If it's a shell option variable, restore the shell option.
			case ${_Msh_pop_V} in
			( _Msh_ShellOpt_a )
				case ${_Msh_ShellOpt_a+s} in
				( s )	_Msh_pop_opta=y
					unset -v _Msh_ShellOpt_a ;;
				( * )	unset -v _Msh_pop_opta ;;
				esac
				;;
			( _Msh_ShellOpt_[bcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
				if isset "${_Msh_pop_V}"; then
					set "-${_Msh_pop_V#_Msh_ShellOpt_}"
					unset -v "${_Msh_pop_V}"
				else
					case $- in
					( *${_Msh_pop_V#_Msh_ShellOpt_}* )
						set "+${_Msh_pop_V#_Msh_ShellOpt_}"
						;;
					esac
				fi
				;;
			esac
		done;; esac
		case ${_Msh_pop_opta+s} in
		( s )	set -a; unset -v _Msh_pop_opta ;;
		esac
		eval "unset -v _Msh_pop_V _Msh_pop_SP _Msh_pop_err; return ${_Msh_pop_err}"
	}
else
	# Canonical version for shells without BUG_ARITHTYPE.
	pop() {
		# Exporting the stack would be bad; run 'pop' without 'set -a' active.
		# Save the status of 'set -a' in a variable so 'pop -a' works.
		case ${#},$- in
		( 0,* )	_Msh_dieArgs pop "$#" 'at least 1' || return ;;
		( *a* )	set +a; _Msh_pop_opta=y ;;
		( * )	unset -v _Msh_pop_opta ;;
		esac

		# Validate everything before doing anything.
		_Msh_pop_err=0
		for _Msh_pop_V do
			case ${_Msh_pop_V} in
			( -[abcdfghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )	# short-form shell option (no 'e' or 'o')
				_Msh_pop_V="_Msh_ShellOpt_${_Msh_pop_V#-}" ;;
			( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
				die "pop: invalid variable name or shell option: $_Msh_pop_V" || { _Msh_pop_err=$?; break; } ;;
			esac

			if isset "_Msh__V${_Msh_pop_V}__SP"; then
				# validate stack pointer
				eval "_Msh_pop_SP=\${_Msh__V${_Msh_pop_V}__SP}"
				case ${_Msh_pop_SP} in
				( '' | 0* | *[!0123456789]* )
					die "pop: Stack pointer for ${_Msh_pop_V} corrupted" || { _Msh_pop_err=$?; break; } ;;
				esac
			else
				# stack empty
				_Msh_pop_err=1
			fi
		done

		# Do the job.
		case ${_Msh_pop_err} in
		( 0 ) for _Msh_pop_V do
			# If shell option, translate to internal variable.
			case ${_Msh_pop_V} in
			( -? )	_Msh_pop_V="_Msh_ShellOpt_${_Msh_pop_V#-}" ;;
			esac

			# Decrease stack pointer so it points to the item to pop.
			: $(( _Msh_pop_SP = ( _Msh__V${_Msh_pop_V}__SP -= 1 ) ))

			# Restore value or unset status.
			if isset "_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}"; then
				eval "${_Msh_pop_V}=\${_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}}"
			else
				unset -v "${_Msh_pop_V}"
			fi

			# Clean up: unset the stack variable we just popped off the stack.
			unset -v "_Msh__V${_Msh_pop_V}__S${_Msh_pop_SP}"

			# Clean up: if the stack is empty, unset the stack pointer.
			case ${_Msh_pop_SP} in
			( 0 )	unset -v "_Msh__V${_Msh_pop_V}__SP" ;;
			esac

			# If it's a shell option variable, restore the shell option.
			case ${_Msh_pop_V} in
			( _Msh_ShellOpt_a )
				case ${_Msh_ShellOpt_a+s} in
				( s )	_Msh_pop_opta=y
					unset -v _Msh_ShellOpt_a ;;
				( * )	unset -v _Msh_pop_opta ;;
				esac
				;;
			( _Msh_ShellOpt_[bcdefghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
				if isset "${_Msh_pop_V}"; then
					set "-${_Msh_pop_V#_Msh_ShellOpt_}"
					unset -v "${_Msh_pop_V}"
				else
					case $- in
					( *${_Msh_pop_V#_Msh_ShellOpt_}* )
						set "+${_Msh_pop_V#_Msh_ShellOpt_}"
						;;
					esac
				fi
				;;
			esac
		done;; esac
		case ${_Msh_pop_opta+s} in
		( s )	set -a; unset -v _Msh_pop_opta ;;
		esac
		eval "unset -v _Msh_pop_V _Msh_pop_SP _Msh_pop_err; return ${_Msh_pop_err}"
	}
fi

# Check if there is anything left on a variable or shell options's stack.
# Returns 0 (true) if the stack is empty, 1 (false) if not.
stackempty() {
	case ${#},${1-} in
	( 1,@ )	! isset "_Msh__V_Msh_PPs__SP" ;;
	( 1,--trap=* )
		_Msh_arg2sig "${1#--trap=}" || die "clearstack: invalid signal specification: ${1#--trap=}" || return
		! isset "_Msh__V_Msh_trap${_Msh_sig}__SP"
		eval "unset -v _Msh_sig; return $?" ;;
	( 1,-[abcdfghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
		! isset "_Msh__V_Msh_ShellOpt_${1#-}__SP" ;;
	( 1, | 1,[0123456789]* | 1,*[!${ASCIIALNUM}_]* | 1,*__[VS]* )
		die "stackempty: invalid variable name or shell option: $1" ;;
	( 1,* )	! isset "_Msh__V${1}__SP" ;;
	( * )	_Msh_dieArgs stackempty "$#" 1 ;;
	esac
}

# Leaves the size of a variable's stack in $REPLY.
stacksize() {
	case ${#},${1-} in
	( 1,@ )	REPLY=${_Msh__V_Msh_PPs__SP:-0} ;;
	( 1,--trap=* )
		_Msh_arg2sig "${1#--trap=}" || die "clearstack: invalid signal specification: ${1#--trap=}" || return
		eval "REPLY=\${_Msh__V_Msh_trap${_Msh_sig}__SP:-0}"
		unset -v _Msh_sig ;;
	( 1,-[abcdfghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
		eval "REPLY=\${_Msh__V_Msh_ShellOpt_${1#-}__SP:-0}" ;;
	( 1,'' | 1,[0123456789]* | 1,*[!${ASCIIALNUM}_]* | 1,*__[VS]* )
		die "stacksize: invalid variable name or shell option: $1" ;;
	( 1,* )	eval "REPLY=\${_Msh__V${1}__SP:-0}" ;;
	( * )	_Msh_dieArgs stackempty "$#" 1 ;;
	esac
}


# Outputs the contents of a variable or shell options's stack, top down, one
# item per line.
# Usage: printstack [ -Q ] <item>
# The <item> can be a variable name, '@', or --trap=<signal>.
# Option -Q shell-quotes each stack value before printing it. This allows
# parsing of multi-line or otherwise complicated values.
# Column 1 of the output contains S if the value is set, U if unset.
# Column 2 to 7 of the output contain the number of the item (down to 0).
# If the item is set, column 8 and 9 contain a colon and a space, and
# column 10 and up contain the value, or '(unset entry)' if the item is unset.
# TODO: Option for bottom-up output
# TODO: Consider if 6 columns for stack number is enough
printstack() {
	_Msh_pSo_Q=''
	case "$#" in
	( 1 )	;;
	( 2 )	case $1 in
		( -- )	shift ;;
		( -Q )	_Msh_pSo_Q=yes; shift ;;
		( -* )	die "printstack: invalid option: $1" || return ;;
		( * )	die "printstack: one non-option argument expected" || return ;;
		esac ;;
	( * )	_Msh_dieArgs printstack "$#" '1 or 2 (excl. option -Q)' || return ;;
	esac
	case $1 in
	( @ )	set -- _Msh_PPs ;;			# positional parameters
	( --trap=* )
		_Msh_arg2sig "${1#--trap=}" || die "printstack --trap: invalid signal specification: ${1#--trap=}" || return
		set -- "_Msh_trap${_Msh_sig}"
		unset -v _Msh_sig ;;
	( -[abcdfghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
		set -- "_Msh_ShellOpt_${1#-}" ;;	# short-form shell option (no 'o')
	( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
		die "printstack: invalid variable name: $1" || return ;;
	esac

	# Return non-success if stack empty.
	if ! isset "_Msh__V${1}__SP"; then
		unset -v _Msh_pSo_Q
		return 1
	fi

	# Validate stack pointer.
	eval "_Msh_pS_i=\${_Msh__V${1}__SP}"
	case ${_Msh_pS_i} in
	( '' | *[!0123456789]* ) die "printstack: Stack pointer for $1 corrupted" || return ;;
	esac

	# Output the stack.
	while let '(_Msh_pS_i-=1) >= 0'; do
		if isset "_Msh__V${1}__S${_Msh_pS_i}"; then
			eval "_Msh_pS_VAL=\${_Msh__V${1}__S${_Msh_pS_i}}"
			case ${_Msh_pSo_Q:+n} in
			( n )	shellquote -f _Msh_pS_VAL ;;
			esac
			printf 'S%6d: %s\n' "${_Msh_pS_i}" "${_Msh_pS_VAL}"
		else
			printf 'U%6d\n' "${_Msh_pS_i}"
		fi
	done

	unset -v _Msh_pS_i _Msh_pSo_Q _Msh_pS_VAL
}

# Empties one or more variables' or shell options' stacks.
# Usage: clearstack <item> [ <item> ... ]
# Empties *nothing* if one of the specified items' stack is already empty.
# This allows for extra validation when treating several items as a group.
clearstack() {
	case $# in
	( 0 )	_Msh_dieArgs clearstack "$#" 'at least 1' || return ;;
	esac

	# Validate everything before doing anything
	for _Msh_cS_V do
		case ${_Msh_cS_V} in
		( @ )	_Msh_cS_V=_Msh_PPs ;;
		( --trap=* )
			_Msh_arg2sig "${_Msh_cS_V#--trap=}" \
			|| die "clearstack --trap: invalid signal specification: ${_Msh_cS_V#--trap=}" || return
			_Msh_cS_V=_Msh_trap${_Msh_sig} ;;
		( -[abcdfghijklmnpqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ] )
			_Msh_cS_V="_Msh_ShellOpt_${_Msh_cS_V#-}" ;;	# short-form shell option (no 'o')
		( '' | [0123456789]* | *[!${ASCIIALNUM}_]* | *__[VS]* )
			die "clearstack: invalid variable name or shell option: $_Msh_cS_V" || return ;;
		esac

		# if the stack for one of the given items is empty, don't clear any of them
		if ! isset "_Msh__V${_Msh_cS_V}__SP"; then
			unset -v _Msh_cS_V _Msh_cS_SP
			return 1
		fi

                eval "_Msh_cS_SP=\${_Msh__V${_Msh_cS_V}__SP}"
		case ${_Msh_cS_SP} in
		( '' | *[!0123456789]* ) die "clearstack: Stack pointer for ${_Msh_cS_V} corrupted" || return ;;
		esac
	done

	# Do the job
	for _Msh_cS_V do
		case ${_Msh_cS_V} in
		( @ )	_Msh_cS_V=_Msh_PPs ;;
		( --trap=* )
			_Msh_arg2sig "${_Msh_cS_V#--trap=}"
			_Msh_cS_V=_Msh_trap${_Msh_sig} ;;
		( -? )	_Msh_cS_V="_Msh_ShellOpt_${_Msh_cS_V#-}" ;;
		esac
		eval "_Msh_cS_SP=\${_Msh__V${_Msh_cS_V}__SP}"
		while let '(_Msh_cS_SP-=1) >= 0'; do
			unset -v "_Msh__V${_Msh_cS_V}__S${_Msh_cS_SP}"
		done
		unset -v "_Msh__V${_Msh_cS_V}__SP"
	done
	unset -v _Msh_cS_V _Msh_cS_SP
}

# -----------------
# ---Trap stack ---

# Convert an argument in ${_Msh_sig} to a signal name, minus the SIG- prefix, and check for validity.
# Internal function. Subject to change without notice.
_Msh_arg2sig() {
	case ${1:+n} in
	( n )	_Msh_sig=$1 ;;
	esac
	case ${_Msh_sig} in
	( 0 )	_Msh_sig='EXIT' ;;	# this is not really a signal
	( 1 )	_Msh_sig='HUP' ;;	# \
	( 2 )	_Msh_sig='INT' ;;	# |
	( 3 )	_Msh_sig='QUIT' ;;	#  \
	( 6 )	_Msh_sig='ABRT' ;;	#   } these are guaranteed by POSIX
	( 9 )	_Msh_sig='KILL' ;;	#  /
	( 14 )	_Msh_sig='ALRM' ;;	# |
	( 15 )	_Msh_sig='TERM' ;;	# /
	( *[!0123456789]* )
		# signal name: make upper case, remove SIG, check validity
		case ${_Msh_sig} in
		( *[a-z]* )
			_Msh_sig=$(command -p printf '%s\n' "${_Msh_sig}" | command -p tr a-z A-Z) ;;
		esac
		_Msh_sig=${_Msh_sig#SIG}
		case ${_Msh_sig} in
		( '' | [0123456789]* | *[!ABCDEFGHIJKLMNOPQRSTUVWXYZ01213456789]* )
			return 1 ;;
		esac ;;
	( * )	# other signal number: ask 'kill' for a name
		_Msh_sig=$(kill -l "${_Msh_sig}" 2>/dev/null) ;;
	esac
}

# Adds a command to each specified signal's trap stack, activating the
# corresponding system trap if it wasn't already active.
# Usage: pushtrap [ -- ] <command> <sigspec> [ <sigspec> ... ]
# (The '--' is in case we decide to support options later, and
# is also consistent with the 'trap' command.)
pushtrap() {
	case ${1-} in
	( -- )	shift ;;
	esac
	case $# in
	( 0|1 )	_Msh_dieArgs pushtrap "$#" 'at least 2' || return ;;
	esac
	_Msh_pushtrapCMD=$1
	shift
	for _Msh_sig do
		_Msh_arg2sig || die "pushtrap: invalid signal specification: ${_Msh_sig}" || return
	done
	for _Msh_sig do
		_Msh_arg2sig
		eval "_Msh_trap${_Msh_sig}=\${_Msh_pushtrapCMD}"
		push "_Msh_trap${_Msh_sig}"
		command trap "_Msh_doTraps ${_Msh_sig}" "${_Msh_sig}" \
			|| die "pushtrap: 'trap' failed" || return
		unset -v "_Msh_trap${_Msh_sig}"
	done
	unset -v _Msh_pushtrapCMD _Msh_sig
}

# Removes a trap from each signal's trap stack without executing it.
# Clear the signal's master trap if there are no more left on the stack.
# Usage: poptrap [ -- ] <sigspec> [ <sigspec> ... ]
# Removes *nothing* if one of the specified signals' stack is already empty;
# this allows for extra validation when treating several items as a group.
# The REPLY variable will be filled with eval-ready (properly shell-quoted)
# commands to re-push each popped trap, each in the form of:
#	pushtrap -- "<command>" SIGNALNAME
# Multiple commands are separated by newline characters.
poptrap() {
	case ${1-} in
	( -- )	shift ;;
	esac
	case $# in
	( 0 )	_Msh_dieArgs poptrap "$#" 'at least 1' || return ;;
	esac
	for _Msh_sig do
		_Msh_arg2sig || die "poptrap: invalid signal specification: ${_Msh_sig}" || return
		isset "_Msh__V_Msh_trap${_Msh_sig}__SP" || return
	done
	unset -v REPLY
	for _Msh_sig do
		_Msh_arg2sig
		# (note: this assumes pop() and shellquote() don't change $REPLY)
		pop "_Msh_trap${_Msh_sig}"
		shellquote -f "_Msh_trap${_Msh_sig}"
		eval "REPLY=\"\${REPLY+\$REPLY\$CCn}pushtrap -- \${_Msh_trap${_Msh_sig}} ${_Msh_sig}\""
		unset -v "_Msh_trap${_Msh_sig}"
		if ! isset "_Msh__V_Msh_trap${_Msh_sig}__SP"; then
			command trap - "${_Msh_sig}"
		fi
	done
	unset -v _Msh_sig
}

# Do the traps for a signal. Start from the top of the stack, but don't pop
# the commands, as they may be trapped repeatedly. Also handle the traps for
# the POSIX 'trap' command defined below.
_Msh_doTraps() {
	# Execute the commands on the trap stack, last to first, if any.
	if isset "_Msh__V_Msh_trap${1}__SP"; then
		_Msh_doTraps_i=$((_Msh__V_Msh_trap${1}__SP))
		while let '(_Msh_doTraps_i-=1) >= 0'; do
			eval "eval \" \${_Msh__V_Msh_trap${1}__S${_Msh_doTraps_i}}\""
				#    ^ QRK_EVALNOOPT compat: can't use '--' so use space for safe arbitrary commands.
				# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_19_16
		done
		unset -v _Msh_doTraps_i
	fi
	# If there is a trap set by the POSIX 'trap' command, excecute it
	# last, in case it contains an 'exit' command. This means POSIX traps
	# should not use any functionality from modernish modules that push
	# their own traps to clean up after themselves.
	if isset "_Msh_POSIXtrap${1}"; then
		eval "eval \" \${_Msh_POSIXtrap${1}}\""
			#    ^ that important space again
	fi
}

# Alias the builtin 'trap' command to a replacement to avoid overwriting other
# traps on the same signal. (Overriding 'trap' with a function doesn't work
# on every shell; an alias is more reliable.) This command should conform to:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#trap
# with the exception that, for compatibility purposes, only an unsigned integer
# of 31 or less is interpreted as an argument to unset a trap.
alias trap='_Msh_POSIXtrap'
_Msh_POSIXtrap() {
	case ${#},${1-} in
	( 0, | 1,-- | *,-p | *,--print )
		# Print the traps, both legacy and stack.
		# (Sadly, something like _Msh_traps=$(trap) does not work on (d)ash, zsh and mksh/lksh: contrary to
		# POSIX, they reset traps in a subshell even if 'trap' is the only command, so we can't read traps
		# from a command substitution subshell. We're forced to create a temporary file instead. Be atomic.)
		_Msh_trapf=$(unset -v F i
			umask 077
			set -C
			i=$((${RANDOM:-$$}*${RANDOM:-${PPID:-$$}}))
			until F=/tmp/_Msh_trapf.$i; command : > "$F"; do
				[ -d /tmp ] && [ -w /tmp ] && [ -x /tmp ] || exit
				i=$((i-1))
			done 2>/dev/null
			echo "$F"
		) || die "trap: can't create temporary file" || return
		if thisshellhas BUG_UPP; then
			command trap ${1+"$@"}
		else
			command trap "$@"
		fi >> "${_Msh_trapf}"
		_Msh_trap_e=$?
		_Msh_trapC=''
		while IFS= read -r _Msh_trapL; do
			_Msh_trapC=${_Msh_trapC:+$_Msh_trapC$CCn}${_Msh_trapL}
		done < "${_Msh_trapf}"
		case $- in
		( *i* )	rm -f "${_Msh_trapf}" ;;
		( * )	rm -f "${_Msh_trapf}" & ;;
		esac
		case ${_Msh_trap_e} in
		( [!0]* )
			die "trap: system 'trap' command failed" || return ;;
		esac
		unset -v _Msh_trap_e
		# We need to list lists all the traps in the form of shell-quoted commands that are suitable for execution
		# by the shell. It is possible for the third argument (the command to execute) to span multiple lines, so
		# just eval-ing them line by line won't work reliably. A more robust method is to alias 'trap' to a shell
		# function, which can easily parse the arguments and print both the stack traps and the POSIX traps.
		alias trap='_Msh_printSysTrap'
		#eval "${_Msh_trapC}"		# this works on bash 3.2, 4.1, 4.2, 4.3, 4.4 but not 4.0
		eval 'eval "${_Msh_trapC}"'	# bash 4.0 will not expand the alias unless 'eval' is wrapped in 'eval'
		_Msh_trapC=$? 
		alias trap='_Msh_POSIXtrap'
		eval "unset -v _Msh_trapf _Msh_trapC _Msh_trapL; return ${_Msh_trapC}" ;;
	( 1,-[!-]* | 1,--?* )
		# allow system-specific things such as "trap -l" (bash) or "trap --help" (ksh93, yash)
		command trap "$@"
		return ;;
	esac
	case $1 in
	( -- )	shift ;;
	esac
	case $1 in
	( - | [0-9] | [12][0-9] | 3[01] )
		# Emulation of system command to unset a trap.
		case $1 in
		( - )	shift ;;
		esac
		for _Msh_sig do
			if _Msh_arg2sig; then
				# a trap handled by the stack: be non-destructive
				#	TODO: with current method, if there are stack traps, the
				#	signal will continue to be ignored after executing those,
				#	which is not what the setter would expect.
				#	Possible strategies:
				#	- Really unset the system trap, which has the effect of deactivating the stack
				#	  traps, but without forgetting them, so stack traps would automagically be
				#	  reactivated if the trap is set again.
				#	- Execute the stack traps, then exit the shell in a way that emulates it
				#	  being killed by that signal.
				if ! isset "_Msh__V_Msh_trap${_Msh_sig}__SP"; then
					command trap - "${_Msh_sig}" || die "trap (unset): builtin 'trap' failed" || return
				fi
				unset -v "_Msh_POSIXtrap${_Msh_sig}" _Msh_sig
			else
				# system-specific or invalid trap
				command trap - "${_Msh_sig}" || die "trap (unset): builtin 'trap' failed" || return
			fi
		done ;;
	( * )	# Emulation of system command to set a trap.
		case $# in
		( 1 )	die "trap (set): at least one signal specification expected" || return ;;
		esac
		_Msh_trap_CMD=$1
		shift
		for _Msh_sig do
			if _Msh_arg2sig; then
				# a trap handled by the stack: play nice with it
				command trap "_Msh_doTraps ${_Msh_sig}" "${_Msh_sig}" \
				|| die "trap (set): builtin 'trap' failed" || return
				eval "_Msh_POSIXtrap${_Msh_sig}=\${_Msh_trap_CMD}"
			else
				# system-specific or invalid trap
				command trap "${_Msh_trap_CMD}" "${_Msh_sig}" \
				|| die "trap (set): builtin 'trap' failed" || return
			fi
		done
		unset -v _Msh_trap_CMD _Msh_sig ;;
	esac
}

# Internal function to interpret the output of the system 'trap' command with no operands.
# We're parsing 'trap' arguments as specified here:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_28_03
_Msh_printSysTrap() {
	case ${#},$1,$3 in
	( 3,--,SIG* )  # just in case we're on non-POSIX bash...
		set -- "$1" "$2" "${3#SIG}" ;;
	( 3,--,* ) ;;
	( * )	die "trap: internal error: unexpected output of system 'trap' command" || return ;;
	esac
	case $2 in
	( "_Msh_doTraps $3" )
		# this trap was set by a modernish function
		unset -v _Msh_pT_cmd
		if isset "_Msh__V_Msh_trap${3}__SP"; then
			# print the traps set by 'pushtrap'
			_Msh_pT_i=-1
			while let "(_Msh_pT_i+=1) < _Msh__V_Msh_trap${3}__SP"; do
				eval "_Msh_pT_cmd=\${_Msh__V_Msh_trap${3}__S${_Msh_pT_i}}"
				shellquote -f _Msh_pT_cmd
				echo "pushtrap -- ${_Msh_pT_cmd} $3"
			done
		fi
		if isset "_Msh_POSIXtrap$3"; then
			# print the trap set by the emulated POSIX 'trap' command
			eval "_Msh_pT_cmd=\${_Msh_POSIXtrap$3}"
			shellquote -f _Msh_pT_cmd
			echo "trap -- ${_Msh_pT_cmd} $3"
		fi
		# if there are neither, but still an _Msh_doTraps system trap, it would do nothing, so...
		if ! isset _Msh_pT_cmd; then
			echo "trap -- '' $3"	# ... reflect that the signal is being ignored
		fi ;;
	( * )	# this trap was set directly by the system command
		_Msh_pT_cmd=$2
		shellquote -f _Msh_pT_cmd
		echo "trap -- ${_Msh_pT_cmd} $3" ;;
	esac
	unset -v _Msh_pT_cmd 
}

# -----------------------------------
# --- Positional parameters stack ---

# Save the current positional parameters on the stack.
if thisshellhas BUG_UPP; then
	alias pushparams='{ _Msh_doPushParams ${1+"$@"}; }'
else
	alias pushparams='{ _Msh_doPushParams "$@"; }'
fi
_Msh_doPushParams() {
	_Msh_PPs=''
	case $# in
	( 0 )	unset -v _Msh_PPs ;;
	( * )	for _Msh_pushparams_P do
			shellquote _Msh_pushparams_P || die "pushparams: 'shellquote' failed" || return
			_Msh_PPs="${_Msh_PPs:+${_Msh_PPs} }${_Msh_pushparams_P}"
		done ;;
	esac
	push _Msh_PPs || die "pushparams: 'push' failed" || return
	unset -v _Msh_PPs _Msh_pushparams_P || :	# BUG_UNSETFAIL compat
}

# Restore the last-pushed positional parameters. Returns successfully if
# there were positional parameters to restore, unsuccessfully if not.
if thisshellhas BUG_UNSETFAIL; then
	alias popparams='{ pop _Msh_PPs && eval "set -- ${_Msh_PPs-}" && { unset -v _Msh_PPs || : ; }; }'
else
	alias popparams='{ pop _Msh_PPs && eval "set -- ${_Msh_PPs-}" && unset -v _Msh_PPs; }'
fi

# -------------

# harden: modernish's replacement for 'set -e' (errexit)
#
# Function that installs a function to harden commands by testing their exit
# status against values indicating error or system failure. Upon failure,
# 'harden' calls 'die', so it will reliably halt program execution, even if
# the failure occurred within a subshell (for instance, in a pipe construct
# or command substitution).
#
# Usage: harden [ -p ] [ as <funcname> ] <commandname/path> <testexpr>
# The <testexpr> is like a shell arithmetic expression, with the binary
# operators '==' '!=' '<=' '>=' '<' '>' turned into unary operators.
# Everything else is the same, including && and || and parentheses.
# Usage examples:
#	harden grep '> 1': grep fails on exit status > 1
#	harden grep '>= 2': equivalent to the above
#	harden gzip '==1 || >2': 1 and >2 are errors, but 2 isn't (see 'man gzip')
#
# What exit status indicates failure depends on the command. For standard
# commands, refer to the POSIX standard. For others, see their manual pages.
#
# To harden a shell function, alias, command with full pathname,
# or any command with a name that would be invalid for a shell
# function, you have harden it 'as' a different name.
#
unset -v _Msh_PIPEstatus
harden() {
	unset -v _Msh_Ho_p
	while :; do
		case ${1-} in
		( -p )	_Msh_Ho_p=y ;;
		( -t )	_Msh_Ho_t=y ;;
		( -pt | -tp )
			_Msh_Ho_p=y; _Msh_Ho_t=y ;;
		( -- )	shift; break ;;
		( -* )	die "harden: invalid option: $1" || return ;;
		( * )	break ;;
		esac
		shift
	done
	case ${#},${1-} in
	( [34],as )
		_Msh_H_func=$2
		_Msh_H_cmd=$(command -v "$3") || die "harden: command not found: '$3'" || return
		shift 2
		;;
	( [12],* )
		_Msh_H_func=$1
		_Msh_H_cmd=$(command -v "$1") || die "harden: command not found: '$1'" || return
		;;
	( * )	die "harden: incorrect arguments${CCn}" \
		"usage: harden [ -p ] [ as <funcname> ] <cmdname/path> [ <testexpr> ]${CCn}" || return
		;;
	esac

	case ${_Msh_H_func} in
	( '' | [0123456789]* | *[!${ASCIIALNUM}_]* )
		die "harden: invalid shell function name: ${_Msh_H_func}" || return
		;;
	# TODO: create a proper check for a shell reserved word
	( 'command' | 'set' | 'return' | 'case' | 'do' | 'done' | 'elif' | 'else' \
	| 'esac' | 'fi' | 'for' | 'if' | 'in' | 'then' | 'until' | 'while' )
		die "harden: can't harden '${_Msh_H_func}'" || return
		;;
	esac

	case ${_Msh_H_cmd} in
	( "alias ${_Msh_H_func}="* )
		die "harden: can't harden an alias as itself: ${_Msh_H_func}" || return
		;;
	( "${_Msh_H_func}" )
		thisshellhas "${_Msh_H_func}" \
		|| die "harden: can't harden a shell function as itself: ${_Msh_H_func}" || return
		# Got shell built-in command.
		if thisshellhas builtin; then
			_Msh_H_BI="builtin "
		else
			_Msh_H_BI="command "
		fi
		;;
	( * )	shellquote _Msh_H_cmd	# in case of weird path names
		_Msh_H_BI=''
		;;
	esac

	# add hardening function's positional parameters as arguments to the real command
	if thisshellhas BUG_UPP; then
		_Msh_H_cmd=${_Msh_H_cmd}' ${1+"$@"}'
	else
		_Msh_H_cmd=${_Msh_H_cmd}' "$@"'
	fi

	# command to store command + positional parameters shellquoted in _Msh_P
	_Msh_H_spp='_Msh_doStoreParams "$((${#}+1))" '${_Msh_H_cmd}' _Msh_P'

	# if caller asked to trace the hardened command, store relevant commands in option variable _Msh_Ho_t
	if isset _Msh_Ho_t; then
		exec 9>&2
		if isonterminal 9 &&
			case ${TERM-} in
			( ansi | xterm* | linux | vt[1-5][0-9][0-9] | cygwin ) ;;
			( * ) false ;;
			esac
		then	# highlight trace in red, yellow and blue
			_Msh_Ho_t="${_Msh_H_spp}
				echo \"\$CCe[0;33m[\$CCe[31m${_Msh_H_func}\$CCe[33m]> \$CCe[1;34m\${_Msh_P}\$CCe[0m\" 1>&9"
		else	# default
			_Msh_Ho_t="${_Msh_H_spp}
				echo \"[${_Msh_H_func}]> \${_Msh_P}\" 1>&9"
		fi
	fi

	# determine status checking method and set hardening function
	_Msh_H_arg=${2:-'>0'}
	if	case ${_Msh_H_arg} in
		( '>0' | '> 0' | '>=1' | '>= 1' ) ;;
		( * ) false ;;
		esac &&
		! isset _Msh_Ho_p
	then	# For efficiency, handle a simple non-zero check specially.
		if isset _Msh_Ho_t; then
			eval "${_Msh_H_func}() {
				${_Msh_Ho_t}
				${_Msh_H_BI}${_Msh_H_cmd} && unset -v _Msh_P || {
					_Msh_E=\$?
					die \"${_Msh_H_func}: command failed with status \${_Msh_E}: \${_Msh_P}\"
					eval \"unset -v _Msh_P _Msh_E; return \${_Msh_E}\"
				}
			}${CCn}"
		else
			eval "${_Msh_H_func}() {
				${_Msh_H_BI}${_Msh_H_cmd} || {
					_Msh_E=\$?
					${_Msh_H_spp}
					die \"${_Msh_H_func}: command failed with status \${_Msh_E}: \${_Msh_P}\"
					eval \"unset -v _Msh_P _Msh_E; return \${_Msh_E}\"
				}
			}${CCn}"
		fi
	else	# Translate the status check expression to an arithmetic expression:
		# unary operators become binary operators with _Msh_E on the left hand
		case ${_Msh_H_arg} in
		( =[!=]* | *[!!\<\>=]=[!=]* | *[%*/+-]=* | *--* | *++* )
			die "harden: assignment not allowed in status expression: '${_Msh_H_arg}'" || return ;;
		esac
		_Msh_H_expr=${_Msh_H_arg}
		for _Msh_H_c in '<' '>' '==' '!='; do
			# use a temporary variable to avoid an infinite loop when
			# replacing all of one character by one or more of itself
			# (algorithm from 'replacein' in var/string.mm)
			_Msh_H_nwex=${_Msh_H_expr}
			_Msh_H_expr=
			while contains "${_Msh_H_nwex}" "${_Msh_H_c}"; do
				_Msh_H_expr=${_Msh_H_expr}${_Msh_H_nwex%%"${_Msh_H_c}"*}\(_Msh_E\)${_Msh_H_c}
				_Msh_H_nwex=${_Msh_H_nwex#*"${_Msh_H_c}"}
			done
			_Msh_H_expr=${_Msh_H_expr}${_Msh_H_nwex}
		done
		unset -v _Msh_H_nwex _Msh_H_c
		if isset _Msh_Ho_p; then
			# We need to be able to whitelist the exit status of processes killed by SIGPIPE,
			# so that things like 'gzip -dc textfile.txt | head' don't kill the program if a
			# hardened 'gzip' is killed by SIGPIPE. Hence the -p option.
			# According to POSIX, the numerical value of SIGPIPE is implementation-defined. In
			# addition, different shells have different exit status offsets for signals: ksh93
			# has signum+256, the rest signum+128. So we have to kill a process with SIGPIPE to
			# find out its exit status. Do this the first time the value is needed.
			if ! isset _Msh_PIPEstatus; then
				case $- in
				( *i* )	"$MSH_SHELL" -c 'kill -s PIPE $$' ;;
				( * )	# Following method from discussions on comp.unix.shell/comp.unix.programmer.
					# Message-ID: <diuks5Fbik0U1@mid.uni-berlin.de>
					# Use it for non-interactive shells only to avoid job control clutter on the terminal.
					(while :; do command -p sleep 1; done) &
					kill -s PIPE "$!"
					wait "$!" ;;
				esac
				_Msh_PIPEstatus=$?
				readonly _Msh_PIPEstatus
			fi
			_Msh_H_expr="(${_Msh_H_expr}) && _Msh_E!=${_Msh_PIPEstatus}"
		fi
		_Msh_E=0
		( : "$((${_Msh_H_expr}))" ) 2>/dev/null || die "harden: invalid status expression: '${_Msh_H_arg}'" || return
		let "${_Msh_H_expr}" && { die "harden: success means failure in status expression: ${_Msh_H_arg}" || return; }

		# Just to make sure:
		{ unalias 'command' 'set' 'return'; unset -f 'command' 'set' 'return'; } 2>/dev/null

		# Set the hardening function.
		# (As an exception, there is no '|| return' after 'die', because if we're in
		# an interactive shell that can't be killed, we want the command to exit with
		# its own status code, not that of 'die'.)
		shellquote _Msh_H_expr
		if isset _Msh_Ho_t; then
			eval "${_Msh_H_func}() {
				${_Msh_Ho_t}
				${_Msh_H_BI}${_Msh_H_cmd} && unset -v _Msh_P || {
					_Msh_E=\$?
					if let ${_Msh_H_expr}; then
						die \"${_Msh_H_func}: command failed with status \${_Msh_E}: \${_Msh_P}\"
					fi
					eval \"unset -v _Msh_P _Msh_E; return \${_Msh_E}\"
				}
			}${CCn}"
		else
			eval "${_Msh_H_func}() {
				${_Msh_H_BI}${_Msh_H_cmd} || {
					_Msh_E=\$?
					if let ${_Msh_H_expr}; then
						${_Msh_H_spp}
						die \"${_Msh_H_func}: command failed with status \${_Msh_E}: \${_Msh_P}\"
					fi
					eval \"unset -v _Msh_P _Msh_E; return \${_Msh_E}\"
				}
			}${CCn}"
		fi
	fi

	unset -v _Msh_Ho_p _Msh_Ho_t _Msh_H_cmd _Msh_H_BI _Msh_H_spp \
		_Msh_H_func _Msh_H_expr _Msh_H_arg _Msh_E || : # BUG_UNSETFAIL compat
}

# -------------

# 'print' and 'echo'
#
# 'print' prints each argument on a separate line (unlike 'echo' which
# prints all arguments on one line). There is no processing of options or
# escape codes. NOTE: this is completely different from ksh/zsh 'print'.
#
# POSIX: "It is not possible to use echo portably across all POSIX systems
# unless both -n (as the first argument) and escape sequences are omitted."
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/echo.html#tag_20_37_16
#
# Provide a modernish version of 'echo', so at least all modernish programs can
# safely expect the same behaviour. This version does not interpret any control
# characters and supports only one option, '-n', which, like BSD 'echo',
# suppresses the newline. However, unlike BSD 'echo', if '-n' is the only
# argument, it is not interpreted as an option and the string '-n' is printed
# instead. This makes it safe to output arbitrary data using this version of
# 'echo' as long as it is given as a single argument (using quoting if needed).

if ! thisshellhas printf && thisshellhas print KSH88FUNC builtin; then
	# pdksh and mksh don't have a 'printf' builtin, and using the external
	# 'printf' command is very slow. But they do have a built-in
	# ksh/zsh-style 'print' command, so here are versions of 'print' and
	# 'echo' that take advantage of it to get much higher performance.
	#
	# (Using 'eval' to avoid syntax error in case modernish is reloaded
	# on a non-{pd,m}ksh shell and 'print' is already an alias.)
	eval 'print() {
		case $# in
		( 0 )	builtin print ;;
		( 1 )	builtin print -r -- "$1" ;;
		( * )	typeset IFS="$CCn" # separator for "$*"
			builtin print -r -- "$*" ;;
		esac
	}'

	echo() {
		case ${#},${1-} in
		( 0, )   builtin print ;;
		( 1,* )  builtin print -r -- "$1" ;;
		( 2,-n ) builtin print -nr -- "$2" ;;
		( *,-n ) typeset IFS=' ' # separator for "$*"
			 shift
			 builtin print -nr -- "$*" ;;
		( * )	 typeset IFS=' '
			 builtin print -r -- "$*" ;;
		esac
	}

else
	# For most shells, use 'printf' for print and echo.
	# The print command can be a simple alias.
	alias print='printf %s\\n'

	if thisshellhas LOCAL local; then
		# bash, ash variants, zsh
		echo() {
			case ${#},${1-} in
			( 0, )   printf '\n' ;;
			( 1,* )  printf '%s\n' "$1" ;;
			( 2,-n ) printf '%s' "$2" ;;
			( *,-n ) local IFS=' ' # separator for "$*"
				 shift
				 printf '%s' "$*" ;;
			( * )	 local IFS=' '
				 printf '%s\n' "$*" ;;
			esac
		}
	elif thisshellhas KSH93FUNC || thisshellhas KSH88FUNC; then
		# AT&T ksh93; yash (non-posixlycorrect)
		# On ksh93, local variables are only supported on functions
		# defined with the 'function' keyword. Use 'eval' to avoid
		# syntax error on shells without that keyword.
		eval 'function echo {
			case ${#},${1-} in
			( 0, )   printf "\n" ;;
			( 1,* )  printf "%s\n" "$1" ;;
			( 2,-n ) printf "%s" "$2" ;;
			( *,-n ) typeset IFS=" " # separator for "$*"
				 shift
				 printf "%s" "$*" ;;
			( * )	 typeset IFS=" "
				 printf "%s\n" "$*" ;;
			esac
		}'
	else
		if thisshellhas BUG_IFSISSET; then
			printf '%s\n' "modernish: Fatal error: You're on a shell with BUG_IFSISSET that is not ksh93!" \
				"This is not known to exist; please report. Aborting." 1>&2
			exit 127
		fi
		# default (POSIX, no local variables)
		echo() {
			case ${#},${1-} in
			( 0, )   printf '\n' ;;
			( 1,* )  printf '%s\n' "$1" ;;
			( 2,-n ) printf '%s' "$2" ;;
			( * )	 case ${IFS+s} in	# not BUG_IFSISSET compatible
				 ( s )	_Msh_echo_IFS=$IFS ;;
				 ( * )	unset -v _Msh_echo_IFS ;;
				 esac
				 IFS=' '
				 case $1 in
				 ( -n )	shift; printf '%s' "$*" ;;
				 ( * )	printf '%s\n' "$*" ;;
				 esac
				 case ${_Msh_echo_IFS+s} in
				 ( s )	IFS=${_Msh_echo_IFS}; unset -v _Msh_echo_IFS ;;
				 ( * )	unset -v IFS ;;
				 esac ;;
			esac
		}
	fi
fi

# -------------

# 'source' as in zsh and bash, with optional positional parameters, now also
# available to (d)ash, yash and *ksh*. If extra arguments are given, they
# are passed to the dot script as local positional parameters as in a shell
# function; if not, the dot script inherits the calling environment's
# positional parameters (unlike a shell function).
#
# In pure POSIX shells, '.' cannot pass extra arguments, and dot scripts
# always inherit the caller's positional parameters; this can be worked
# around with a shell function. However, this is implementation-dependent;
# in bash, *ksh* and zsh, '.' does pass the parameters. Modernish scripts
# should use 'source' instead of '.' for consistent functionality.
#
# Sourcing the script as the last command in the function works around a quirk
# in FreeBSD /bin/sh where 'return' from a dot script called by a function
# returns from the calling function and not just the dot script.
if ! thisshellhas source; then
	if thisshellhas DOTARG; then
		alias source=.
	else
		if thisshellhas BUG_UPP; then
			alias source='_Msh_doSource "$#" ${1+"$@"}'
		else
			alias source='_Msh_doSource "$#" "$@"'
		fi
		_Msh_doSource() {
			let "$# > ( $1 + 1 )" || _Msh_dieArgs source 0 'at least 1' || return
			eval "_Msh_source_S=\${$(( $1 + 2 ))}"

			if let "$# > ( $1 + 2 )"; then
				# extra arguments were given; discard the number of caller's positional parameters, the
				# caller's positional parameters themselves, and the argument indicating the dot script
				shift "$(( $1 + 2 ))"
			else
				# no extra arguments were given; keep caller's positional parameters, but remove the number
				# of them (first parameter) and the argument indicating the dot script (last parameter)
				if let "$1 > 0"; then
					_Msh_source_P=''
					while let "$# > 2"; do
						_Msh_source_V=$2
						shellquote _Msh_source_V
						_Msh_source_P="${_Msh_source_P} ${_Msh_source_V}"
						shift
					done
					eval "set -- ${_Msh_source_P}"
					unset -v _Msh_source_P _Msh_source_V
				else
					set --
				fi
			fi

			# Unlike '.', find the dot script in the current directory, not just in $PATH.
			case ${_Msh_source_S} in
			( */* )	;;
			( * )	if [ -f "./${_Msh_source_S}" ]; then
					_Msh_source_S=./${_Msh_source_S}
				fi ;;
			esac

			shellquote _Msh_source_S
			eval "unset -v _Msh_source_S; . ${_Msh_source_S}"
		}
	fi
fi

# -------------

# Implementation of 'let' as in ksh, bash, zsh and busybox ash, for shells
# without it.
# Usage: let <expr> [ <expr> ... ]
# where <expr> is an arithmetic expression as in $(( ... )).
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/V3_chap02.html#tag_18_06_04
#
# The exit status is 1 if the last expression evaluates to 0, and 0 if not.
# (0 and 1 in C-style boolean are the opposite of 0 and 1 in shell boolean, so
# this means it does the right true-or-false thing for the shell.)
#
# NOTE: the prefix and postfix "++" and "--" operators are NOT required by
# POSIX and not portable. The ID 'ARITHPP' is assigned to this feature, so
# if you want to use ++/-- you should first check if "thisshellhas ARITHPP".
# Otherwise, for example, instead of 'let X++', use 'let X+=1'.
#
# Shells immediately exit on arith evaluation error, so the usual "|| die"
# check on errors is ineffective.
#
# There are two portability problems with 'let' builtins:
#   1.	On AT&T ksh, the first expression cannot start with a '-' as it will
#	be interpreted as an option, even though its "let" doesn't have any
#	valid options. The end-of-options delimeter '--' is needed for the
#	first expression to start with '-'. However, on pdksh/mksh and
#	Busybox ash, '--' is not accepted and will throw a syntax error.
#	These situations are irreconcilable without a workaround.
#	(Bash and zsh accept '--' but don't require them, even if the first
#	expression starts with '-'.)
#   2.  Some ash derivatives (such as FreeBSD /bin/sh) have an undocumented
#	and incompatible 'let' builtin that only takes one expression (and
#	uselessly outputs the result to standard output).
# So let's test if we have a version that works as expected and override the
# builtin if it's not up to scratch.
unset -v _Msh_X _Msh_Y _Msh_goodlet
if thisshellhas let; then
	if let -- -1\<0 _Msh_X=1 _Msh_Y=_Msh_X+3 \
	&& case ${_Msh_X-},${_Msh_Y-} in ( 1,4 ) ;; ( * ) false ;; esac \
	&& unset -v _Msh_X _Msh_Y
	then
		# Workaround for AT&T ksh to make things like 'let -1==var' or 'let --var' work.
		# For consistency, also use '--' on other shells whose 'let' builtin supports it;
		# this makes sure 'let' in modernish scripts do not accept '--' on any shell,
		# instead of accepting it on some shells but not on others.
		alias let='let --'
		_Msh_goodlet=y
	elif let -1\<0 _Msh_X=1 _Msh_Y=_Msh_X+3 \
	&& case ${_Msh_X-},${_Msh_Y-} in ( 1,4 ) ;; ( * ) false ;; esac \
	&& unset -v _Msh_X _Msh_Y
	then
		# Use the builtin as is: mksh/lksh, Busybox ash
		_Msh_goodlet=y
	fi
fi 2>/dev/null
case ${_Msh_goodlet+s} in
( s )	unset -v _Msh_goodlet ;;
( * )	# We're on a shell with a missing or incompatible 'let' builtin, so provide our own.
	# Speed-optimize it by processing up to 8 expressions at once. (Quoting the parameters
	# to the : no-op command also slightly speeds it up, because field splitting and
	# pathname expansion are not performed.) This modernish version, like pdksh/mksh and
	# Busybox ash, does not accept the '--' end-of-options delimiter.
	# (Using 'eval' to avoid syntax error in case an alias let='let --' was set above.)
	eval 'let() {
		case $# in
		( 1 )	return "$((!($1)))" ;;
		( 2 )	: "$(($1))"
			return "$((!($2)))" ;;
		( 3 )	: "$(($1))$(($2))"
			return "$((!($3)))" ;;
		( 4 )	: "$(($1))$(($2))$(($3))"
			return "$((!($4)))" ;;
		( 5 )	: "$(($1))$(($2))$(($3))$(($4))"
			return "$((!($5)))" ;;
		( 6 )	: "$(($1))$(($2))$(($3))$(($4))$(($5))"
			return "$((!($6)))" ;;
		( 7 )	: "$(($1))$(($2))$(($3))$(($4))$(($5))$(($6))"
			return "$((!($7)))" ;;
		( 8 )	: "$(($1))$(($2))$(($3))$(($4))$(($5))$(($6))$(($7))"
			return "$((!($8)))" ;;
		( 0 )	die "let: expression expected" || return ;;
		( * )	: "$(($1))$(($2))$(($3))$(($4))$(($5))$(($6))$(($7))$(($8))"
			shift 8
			let "$@" ;;
		esac
	}' ;;
esac

# -------------

# Simple integer arith shortcuts.
# Usage: inc/dec/mult/div/mod <varname> [ <expr> ]
# Increase/decrease/multiply/divide/modulus the value of the variable by the
# result of the integer arithmetic expression <expr>. Default for <expr> is
# 1 for 'inc' and 'dec', 2 for 'mult' and 'div', 256 for 'mod'.
# TODO: figure out sensible default for 'mod'.
#
# The arith operator itself does sufficient validation, though error messages
# are not always very clear. Shells exit on error, so the usual "|| die" is
# ineffective.
#
# (Note: ARITHCMD versions would not be exactly equivalent as ((...)) returns
# an exit status of 1 if the result of the arithmetic expression is 0.)
inc()  { : "$((${1?inc: needs 1 or 2 arguments}+=(${2-1})${3+\\$CCn[ inc: excess arguments ]}))"; }
dec()  { : "$((${1?dec: needs 1 or 2 arguments}-=(${2-1})${3+\\$CCn[ dec: excess arguments ]}))"; }
mult() { : "$((${1?mult: needs 1 or 2 arguments}*=(${2-2})${3+\\$CCn[ mult: excess arguments ]}))"; }
div()  { : "$((${1?div: needs 1 or 2 arguments}/=(${2-2})${3+\\$CCn[ div: excess arguments ]}))"; }
mod()  { : "$((${1?mod: needs 1 or 2 arguments}%=(${2-256})${3+\\$CCn[ mod: excess arguments ]}))"; }

# ndiv: always round down, even for negative numbers.
# Usage: ndiv <varname> [ <expr> ]
# ndiv is like div, but always returns the integer on or before
# $((varname / expr)), even for negative numbers. Standard shell
# arith just chops off the digits after the decimal point, which
# is not ok for negative. (The idea is from wide_strftime.sh by
# Stéphane Chazelas: http://stchaz.free.fr)
# Since we need to access the value of $2 several times, store it in a
# variable to avoid the expression from being evaluated multiple times
# (otherwise things like additive assignment would wreak havoc).
ndiv() { : "$((_Msh_ndiv=(${2-2})))" \
"$((${1?ndiv: needs 1 or 2 arguments} = \
(($1/_Msh_ndiv)*_Msh_ndiv > $1) ? $1/_Msh_ndiv-1 : $1/_Msh_ndiv \
${3+\\$CCn[ ndiv: excess arguments ]} ))"
}

# -------------

# Safer replacement functions for 'test'/'[', which is hereby deprecated
# for legibility and security reasons.
#
# TODO: writeup re 'test' security, e.g. variable injection "-o 1 -eq 1";
# generally too many syntax ambiguity pitfalls) Ref.:
# http://pubs.opengroup.org/onlinepubs/9699919799/utilities/test.html

# --- Integer number arithmetic tests. ---

# These have the sames name as their 'test'/'[' option equivalents. Unlike
# with 'test', the arguments are shell integer arith expressions, which can
# be anything from simple numbers to complex expressions. As with $(( )),
# variable names are expanded to their values even without the '$'.
#
# Portability note: bash, ksh and zsh do recursive evaluation of variable
# names (where a variable can contain the name of another variable, and so
# forth), but that is non-standard and unportable.
#
# Function:		Returns succcessfully if:
# --------		------------------------
# eq <expr> <expr>	the two expressions evaluate to the same number
# ne <expr> <expr>	the two expressions evaluate to different numbers
# lt <expr> <expr>	the 1st expr evaluates to a smaller number than the 2nd
# le <expr> <expr>	the 1st expr eval's to smaller than or equal to the 2nd
# gt <expr> <expr>	the 1st expr evaluates to a greater number than the 2nd
# ge <expr> <expr>	the 1st expr eval's to greater than or equal to the 2nd
#
# Example:
# if eq 2+2 4; then echo 'freedom granted; all else follows'; fi
#
# The arith operator itself does sufficient validation on all shells, though
# error messages are not always very clear.
#
# As a performance hack, the functions below abuse this arith validation in
# combination with parameter substitution to check for excess arguments, by
# injecting a guaranteed-to-be-invalid value (starting with an escaped '\') in
# case of excess arguments. According to my tests, this is completely reliable
# in every shell, and causes no noticable performance reduction. Not only
# that, many shells (not zsh or yash) helpfully insert the invalid value into
# its own error message, so we can add our own message ('excess arguments') to
# be passed on.
#
# Shells exit on arith evaluation errors, so the usual "|| die" is ineffective
# and we can't terminate the program properly from a subshell. I have made the
# choice that the performance gain is worth it in this instance.
if thisshellhas ARITHCMD; then
	eval '
	eq() { (((${1?eq: needs 2 arguments})==(${2?eq: needs 2 arguments})${3+\\[ eq: excess arguments ]})); }
	ne() { (((${1?ne: needs 2 arguments})!=(${2?ne: needs 2 arguments})${3+\\[ ne: excess arguments ]})); }
	lt() { (((${1?lt: needs 2 arguments})<(${2?lt: needs 2 arguments})${3+\\[ lt: excess arguments ]})); }
	le() { (((${1?le: needs 2 arguments})<=(${2?le: needs 2 arguments})${3+\\[ le: excess arguments ]})); }
	gt() { (((${1?gt: needs 2 arguments})>(${2?gt: needs 2 arguments})${3+\\[ gt: excess arguments ]})); }
	ge() { (((${1?ge: needs 2 arguments})>=(${2?ge: needs 2 arguments})${3+\\[ ge: excess arguments ]})); }
	'
else
	# Note: the inversion of comparison operators is NOT a bug! POSIX arith is
	# based on the C language, so uses 1 for true and 0 for false, whereas the
	# shell language itself does the inverse. The fastest way to invert the result
	# code is to invert the operators.
	eq() { return "$(((${1?eq: needs 2 arguments})!=(${2?eq: needs 2 arguments})${3+\\[ eq: excess arguments ]}))"; }
	ne() { return "$(((${1?ne: needs 2 arguments})==(${2?ne: needs 2 arguments})${3+\\[ ne: excess arguments ]}))"; }
	lt() { return "$(((${1?lt: needs 2 arguments})>=(${2?lt: needs 2 arguments})${3+\\[ lt: excess arguments ]}))"; }
	le() { return "$(((${1?le: needs 2 arguments})>(${2?le: needs 2 arguments})${3+\\[ le: excess arguments ]}))"; }
	gt() { return "$(((${1?gt: needs 2 arguments})<=(${2?gt: needs 2 arguments})${3+\\[ gt: excess arguments ]}))"; }
	ge() { return "$(((${1?ge: needs 2 arguments})<(${2?ge: needs 2 arguments})${3+\\[ ge: excess arguments ]}))"; }
fi

# Test if the given argument is a valid integer number in shell syntax. Decimal
# /[+-]*[0-9]+/, octal /[+-]0[0-7]*/ and hexadecimal /[+-]0[xX][0-9a-fA-F]+/
# are supported. For peformance, express these extended regular expressions in
# rather convoluted glob patterns for 'case'.
# Tolerate only leading and not trailing whitespace; most shells
# tolerate both in arithmetic expansion, but yash and FreeBSD /bin/sh only
# tolerate leading whitespace in values expanded from variables, so use the
# most restrictive/compatible check. (Quirk ID: QRK_ARITHWHSP)
# Discussion: https://osdn.jp/ticket/browse.php?group_id=3863&tid=36002
# See also strtol(3) and wcstol(3) which tolerate only leading whitespace.
# http://pubs.opengroup.org/onlinepubs/9699919799/functions/strtol.html
# http://pubs.opengroup.org/onlinepubs/9699919799/functions/wcstol.html
if thisshellhas BUG_NOCHCLASS; then
	isint() {
		case $# in
		( 1 )	case ${1#"${1%%[!$WHITESPACE]*}"} in								# "
			( 0[xX]*[!0123456789abcdefABCDEF]* | [+-]0[xX]*[!0123456789abcdefABCDEF]* )
				return 1 ;;
			( 0[xX]?* | [+-]0[xX]?* )
				;;
			( '' | [+-] | ?*[+-]* | *[!0123456789+-]* | 0*[!01234567]* | [+-]0*[!01234567]* )
				return 1 ;;
			esac ;;
		( 0 )	return 1 ;;
		( * )	_Msh_dieArgs isint "$#" '0 or 1' || return ;;
		esac
	}
else
	isint() {
		case $# in
		( 1 )	case ${1#"${1%%[![:space:]]*}"} in								# "
			( 0[xX]*[!0123456789abcdefABCDEF]* | [+-]0[xX]*[!0123456789abcdefABCDEF]* )
				return 1 ;;
			( 0[xX]?* | [+-]0[xX]?* )
				;;
			( '' | [+-] | ?*[+-]* | *[!0123456789+-]* | 0*[!01234567]* | [+-]0*[!01234567]* )
				return 1 ;;
			esac ;;
		( 0 )	return 1 ;;
		( * )	_Msh_dieArgs isint "$#" '0 or 1' || return ;;
		esac
	}
fi

# ---- String tests. ----
# (Negative string tests are not provided; just put 'not' or '!' before them)

# Test for the empty string. Usage: empty <value>
#	Unlike "test -z", this function deals correctly with the POSIX
#	shell's non-optional removal of unquoted empty arguments: it accepts
#	zero arguments as equivalent to empty. That means, if you 'use safe',
#	you can do 'if empty $var' without having to quote $var, because
#	field splitting or globbing are turned off.
#	The function treats more than one argument as a fatal error, because
#	that is a sign of unexpected field splitting or globbing.
empty() {
	case ${#}${1:+n} in
	( 0 | 1 ) ;;
	( 1n ) return 1 ;;
	( * ) _Msh_dieArgs empty "$#" '0 or 1' ;;
	esac
}

# Test for identical strings. Usage: identic <value1> <value2>
#	This function deals correctly with the POSIX shell's non-optional
#	removal of unquoted empty arguments: it accepts zero arguments as
#	equivalent to "identical" (i.e. two removed empties) and one
#	argument as "not identical" (one removed empty, one non-empty).
#	That means, if you 'use safe', you can do 'if identic $var1 $var2'
#	without having to quote $var1 and $var2, provided field splitting or
#	globbing are not turned on.
#	The function treats more than two arguments as a fatal error,
#	because that is a sign of unexpected field splitting or globbing.
identic() {
	case ${#},${1-} in
	( 0, | 2,"${2-}" ) ;;
	( [12],* ) return 1 ;;
	( * ) _Msh_dieArgs identic "$#" 'max. 2' ;;
	esac
}

# For lexical comparison, unfortunately [ '<' and '>' ] are not POSIX, but
# the standards-compliant way requires the external 'expr' utility. So let's
# see what this particular shell supports and fall back on 'expr', making
# sure that it works even if the arguments contain newline characters.
#
#	(Unfortunately, dealing with empty removal as in identic() above is
#	impossible, because if there is only one removed empty argument,
#	then you cannot tell whether it was the first or second argument, so
#	it's impossible to tell how it sorts. So if there is the possibility
#	of empty variables, they must always be quoted, even under 'use
#	safe'.)
#
# ...	If we're running on bash, ksh or zsh:
if PATH=/dev/null; eval "[[ 'a${CCn}b' < 'a${CCn}bb' && 'a${CCn}bb' > 'a${CCn}b' ]]"
then
	PATH=${_Msh_PATH}
	sortsbefore() {
		case $# in
		( 2 )	[[ $1 < $2 ]] ;;
		( * )	_Msh_dieArgs sortsbefore "$#" 2 ;;
		esac
	}
	sortsafter() {
		case $# in
		( 2 )	[[ $1 > $2 ]] ;;
		( * )	_Msh_dieArgs sortsafter "$#" 2 ;;
		esac
	}
# ...	Try to fall back to builtin '['/'test' non-standard feature.
#	Thankfully, '<' and '>' are pretty widely supported for this
#	builtin. Unlike with [[ ]], we need to quote everything.
elif PATH=/dev/null; eval "[ 'a${CCn}b' '<' 'a${CCn}bb' ] && [ 'a${CCn}bb' '>' 'a${CCn}b' ]"
then
	PATH=${_Msh_PATH}
	sortsbefore() {
		case $# in
		( 2 )	[ "X$1" '<' "X$2" ] || { let "$? > 1" && die "sortsbefore: '[' failed"; } ;;
		( * )	_Msh_dieArgs sortsbefore "$#" 2 ;;
		esac
	}
	sortsafter() {
		case $# in
		( 2 )	[ "X$1" '>' "X$2" ] || { let "$? > 1" && die "sortsafter: '[' failed"; } ;;
		( * )	_Msh_dieArgs sortsafter "$#" 2 ;;
		esac
	}

# ...	Fall back to the POSIX way with 'expr'.
elif PATH=${_Msh_PATH}; eval "command -p expr 'a${CCn}b' '<' 'a${CCn}bb' && ! command -p expr 'a${CCn}bb' '<' 'a${CCn}b'"
then
	sortsbefore() {
		case $# in
		( 2 )	command -p expr "X$1" '<' "X$2" >/dev/null || { let "$? > 1" && die "sortsbefore: 'expr' failed"; } ;;
		( * )	_Msh_dieArgs sortsbefore "$#" 2 ;;
		esac
	}
	sortsafter() {
		case $# in
		( 2 )	command -p expr "X$1" '>' "X$2" >/dev/null || { let "$? > 1" && die "sortsafter: 'expr' failed"; } ;;
		( * )	_Msh_dieArgs sortsafter "$#" 2 ;;
		esac
	}
else
	printf '%s\n' "Can't run modernish: no valid 'expr' command in default system path." 1>&3
	[ -e "$HOME/.modernish-force" ] || exit 127
	printf "Proceeding anwyay. 'sortsbefore' and 'sortsafter' won't work." 1>&3
fi 3>&2 >/dev/null 2>&1

# String comparison tests:
# Usage: <contains|startswith|endswith> <string> <string>
# Return successfully if the first string contains, starts with or ends with the
# second string, unsuccessfully otherwise.
# Empty removal handling: if one argument is omitted, assume the first was a
# removed unquoted empty parameter and return false. 0 arguments = fatal error.
contains() {
	case ${#},${1-} in
	( 2,*"${2-}"* )	;;
	( [12],* )	return 1 ;;
	( * )		_Msh_dieArgs contains "$#" '2 or 1' ;;
	esac
}
startswith() {
	case ${#},${1-} in
	( 2,"${2-}"* )	;;
	( [12],* )	return 1 ;;
	( * )		_Msh_dieArgs startswith "$#" '2 or 1' ;;
	esac
}
endswith() {
	case ${#},${1-} in
	( 2,*"${2-}" )	;;
	( [12],* )	return 1 ;;
	( * )		_Msh_dieArgs endswith "$#" '2 or 1' ;;
	esac
}

# Glob pattern test.
# Usage: match <string> <glob-pattern>
#
# Unfortunately, many shells (zsh, ash, *ksh, ...) don't properly support
# passing a glob pattern with escaped characters from a variable. Escaping
# behaviour with glob patterns in variables varies wildly from shell to
# shell. Bash and dash follow the standard, but too many don't. To ensure
# portability, we must ban the \ from the glob pattern, and accept that
# escaping glob characters to match a literal '*', '?' or '[' using this
# function is impossible.
#
# When matching single characters, beware of BUG_MULTIBYTE!
#
# Empty removal handling: if one argument is omitted, assume the first was a
# removed unquoted empty parameter and return false. 0 arguments = fatal error.
match() {
	case ${#},${1-},${2-} in
	( 2,"${1-}",*\\* )
		die "match: Backslash-escaping is not supported in glob patterns." ;;
	( 2,${2-},"${2-}" )
		;;
	( [12],* )
		return 1 ;;
	( * )	_Msh_dieArgs match "$#" '2 or 1' ;;
	esac
}

# Extended regular expression test.
# Usage: ematch <string> <extended-regex>
#
# Use the [[ keyword (or '[' on yash) if available and if it supports
# extended regular expressions. This is much faster than the standard method
# which involves invoking the external grep command.
#
# When matching single characters, beware of BUG_MULTIBYTE!
#
# Empty removal handling: if one argument is omitted, assume the first was a
# removed unquoted empty parameter and return false. 0 arguments = fatal error.
#
# TODO:	Work around inconsistencies with (a) empty regex or (b) multi-line
#	regex. Some shells' "[[" and "grep -E" act differently from each other.
if ( PATH=/dev/null; eval "[[ xyz =~ ^[a-z]+$ ]]" ); then
	# Wrap the function definition in 'eval', otherwise shells that
	# have '[[' but don't support '=~' fail to parse the script.
	eval 'ematch() {
		case $# in
		( 2 )	[[ $1 =~ $2 ]] ;;
		( 1 )	return 1 ;;
		( * )	_Msh_dieArgs ematch "$#" "2 or 1" ;;
		esac
	}'
# ('eval' is needed by zsh below, otherwise it will exit main shell at this
# point if its regex module is not found)
elif eval "[ xyz '=~' '^[a-z]+\$' ]"; then
	# yash supports extended regex matching in builtin test/[.
	ematch() {
		case $# in
		( 2 )	[ "$1" '=~' "$2" ]  || { let "$? > 1" && die "ematch: '[' failed"; } ;;
		( 1 )	return 1 ;;
		( * )	_Msh_dieArgs ematch "$#" '2 or 1' ;;
		esac
	}
else
	# default/POSIX: use grep (this is some 30-60 times slower).
	ematch() {
		case $# in
		( 2 )	printf '%s\n' "$1" | command -p grep -qE "$2" || { let "$? > 1" && die "ematch: 'grep' failed"; } ;;
		( 1 )	return 1 ;;
		( * )	_Msh_dieArgs ematch "$#" '2 or 1' ;;
		esac
	}
fi 2>/dev/null

# --- General file tests. ---

# exists "$file": tests if file exists.
# exists -L "$file": tests if file exists and is not an invalid symlink.
# (This is written to cope correctly with a file with the literal name '-L',
# without the need to add '--', even though -L is also an option.)
if thisshellhas [[; then
	# Use [[ if available because it's generally faster and more robust;
	# this also avoids BUG_TESTPAREN in zsh 5.0.6/5.0.7 which makes it
	# impossible for test/[ to check for files named '(', ')' or '!'.
	exists() {
		case ${#},${1-} in
		( 1,* )		[[ -e $1 || -L $1 ]] ;;
		( 2,-L )	[[ -e $2 ]] ;;
		( 2,-* )	die "exists: invalid option: $1" || return ;;
		( 2,* )		die "exists: only one non-option argument allowed" || return ;;
		( * )		_Msh_dieArgs exists "$#" '1 or 2' || return ;;
		esac
	}
else
	exists() {
		case ${#},${1-} in
		( 1,* )		[ -e "$1" ] || { let "$? <= 1" || die "exists: '[' failed" || return; [ -L "$1" ]; } ;;
		( 2,-L )	[ -e "$2" ] ;;
		( 2,-* )	die "exists: invalid option: $1" || return ;;
		( 2,* )		die "exists: only one non-option argument allowed" || return ;;
		( * )		_Msh_dieArgs exists "$#" '1 or 2' || return ;;
		esac || { let "$? > 1" && die "exists: '[' failed"; }
	}
fi

# Test if file exists, is not an invalid symlink, and is non-empty. Unlike
# 'test -s', this also works for directories in which you have read
# permission. A race condition with tests like this is inevitable (even
# with the traditional 'test -s'). Be careful with parallel processing!
# Exit status:
# 0: file or directory (after resolving any symlinks) is not empty
# 1: file or directory is empty, doesn't exist, or is an invalid symlink
# 2: no read permission in directory, so cannot test if directory is empty
# The directory testing method was kindly provided by Stéphane Chazelas in:
# Message-ID: <20150524190928.GB6744@chaz.gmail.com>
# https://groups.google.com/forum/#!original/comp.unix.shell/M_gDU9uk8Rk/FyiS9m-RFYAJ
if thisshellhas [[; then
	# Use [[ if available because it's generally faster and more robust;
	# this also avoids BUG_TESTPAREN in zsh 5.0.6/5.0.7 which makes it
	# impossible for test/[ to check for files named '(', ')' or '!'.
	isnonempty() {
		case $# in
		( 1 )	if [[ -d $1 ]]; then
				[[ -r $1 && -x $1 ]] || return 2
				case $- in
				( *f* ) set +f; set -- "$1" "$1"/[*] "$1"/* "$1"/.[!.]* "$1"/.??*; set -f ;;
				( * )	set -- "$1" "$1"/[*] "$1"/* "$1"/.[!.]* "$1"/.??* ;;
				esac
				[[ "${#} $2 $3 $4 $5" != "5 $1/[*] $1/* $1/.[!.]* $1/.??*" ]]
			else
				_Msh_fileTest isnonempty s -L "$@"
			fi ;;
		( * )	_Msh_dieArgs isnonempty "$#" 1 || return ;;
		esac
	}
else
	isnonempty() {
		case $# in
		( 1 )	if [ -d "$1" ] || { let "$? > 1" && die "isnonempty: '[ -d' failed"; }; then
				[ -r "$1" ] && [ -x "$1" ] || { let "$? > 1" && die "isnonempty: '[' failed"; } || return 2
				case $- in
				( *f* ) set +f; set -- "$1" "$1"/[*] "$1"/* "$1"/.[!.]* "$1"/.??*; set -f ;;
				( * )	set -- "$1" "$1"/[*] "$1"/* "$1"/.[!.]* "$1"/.??* ;;
				esac
				case "${#} $2 $3 $4 $5" in
				( "5 $1/[*] $1/* $1/.[!.]* $1/.??*" )
					return 1 ;;
				esac
			else
				_Msh_fileTest isnonempty s -L "$@"
			fi ;;
		( * )	_Msh_dieArgs isnonempty "$#" 1 || return ;;
		esac
	}
fi

# --- File permission tests. ---
# Note: These automatically resolve symlinks.

# Test if this program can read from or write to a file or directory. Work
# around botched '['/'[[' logic that claims you can (-r)ead from or (-w)rite
# to a directory even if its "x" bit is not set.
if thisshellhas [[; then
	# Use [[ if available because it's generally faster and more robust;
	# this also avoids BUG_TESTPAREN in zsh 5.0.6/5.0.7 which makes it
	# impossible for test/[ to check for files named '(', ')' or '!'.
	canread() {
		case $# in
		( 1 )	if	[[ -d $1 ]]
			then	[[ -r $1 && -x $1 ]]
			else	[[ -r $1 ]]
			fi ;;
		( * )	_Msh_dieArgs "canread" $# 1 ;;
		esac
	}
	canwrite() {
		case $# in
		( 1 )	if	[[ -d $1 ]]
			then	[[ -w $1 && -x $1 ]]
			else	[[ -w $1 ]]
			fi ;;
		( * )	_Msh_dieArgs "canwrite" $# 1 ;;
		esac
	}
else
	canread() {
		case $# in
		( 1 )	if	[ -d "$1" ] || { let "$? > 1" && die "canread: '[ -d' failed"; }
			then	[ -r "$1" ] && [ -x "$1" ]
			else	[ -r "$1" ]
			fi || { let "$? > 1" && die "canread: '[' failed"; } ;;
		( * )	_Msh_dieArgs "canread" $# 1 ;;
		esac
	}
	canwrite() {
		case $# in
		( 1 )	if	[ -d "$1" ] || { let "$? > 1" && die "canwrite: '[ -d' failed"; }
			then	[ -w "$1" ] && [ -x "$1" ]
			else	[ -w "$1" ]
			fi || { let "$? > 1" && die "canwrite: '[' failed"; } ;;
		( * )	_Msh_dieArgs "canwrite" $# 1 ;;
		esac
	}
fi

# Test if file is executable or directory is pass-throughable.
alias canexec='_Msh_fileTest canexec x -L'

# Test if file has user or group ID bits set.
alias issetuid='_Msh_fileTest issetuid u -L'
alias issetgid='_Msh_fileTest issetgid g -L'

# Test if file is owned by user or by current user's main group.
# (Note: the -O and -G test/[ operators are technically non-standard, but
# their support in shells that can run the rest of modernish is universal.)
alias ismine='_Msh_fileTest ismine O -L'
alias ismygroup='_Msh_fileTest ismygroup G -L'

# --- File type tests. ---

# Test if file is a symlink.
alias issym='_Msh_fileTest issym L -L'

# Note: The following tests do *not* resolve symlinks unless the -L option is
# used. This is to promote security and discourage allowing symlink attacks.

alias isreg='_Msh_fileTest isreg f'
alias isdir='_Msh_fileTest isdir d'
alias isfifo='_Msh_fileTest isfifo p'
alias issocket='_Msh_fileTest issocket S'
alias isblockspecial='_Msh_fileTest isblockspecial b'
alias ischarspecial='_Msh_fileTest ischarspecial c'

# Internal function. Not for direct use.
# (It is written to cope correctly with a file with the literal name '-L',
# without the need to add '--', even though -L is also an option.)
# TODO: cope with empty removal
if thisshellhas [[; then
	# Use [[ if available because it's generally faster and more robust;
	# this also avoids BUG_TESTPAREN in zsh 5.0.6/5.0.7 which makes it
	# impossible for test/[ to check for files named '(', ')' or '!'.
	# Drawback: can't pass operator through parameter except with 'eval'.
	_Msh_fileTest() {
		case ${#},${3-} in
		( 3,* )		eval "[[ ! -L \$3 && -$2 \$3 ]]" ;;
		( 4,-L )	eval "[[ -$2 \$4 ]]" ;;
		( 4,-* )	die "$1: invalid option: $3" || return ;;
		( 4,* )		die "$1: only one non-option argument allowed" || return ;;
		( * )		_Msh_dieArgs "$1" "$((${#}-2))" '1 or 2' || return ;;	# BUG_HASHVAR workaround: '${#}'
		esac
	}
else
	_Msh_fileTest() {
		case ${#},${3-} in
		( 3,* )		[ ! -L "$3" ] && [ "-$2" "$3" ] ;;
		( 4,-L )	[ "-$2" "$4" ] ;;
		( 4,-* )	die "$1: invalid option: $3" || return ;;
		( 4,* )		die "$1: only one non-option argument allowed" || return ;;
		( * )		_Msh_dieArgs "$1" "$((${#}-2))" '1 or 2' || return ;;	# BUG_HASHVAR workaround: '${#}'
		esac || { let "$? > 1" && die "$1: '[' failed"; }
	}
fi

# Test if file descriptor is open and associated with a terminal.
# (Note: POSIX specifies that file descriptors can be 0 to minimum 19,
# but most shells only support file descriptors between 0 and 9.)
if thisshellhas [[; then
	isonterminal() {
		case ${#},${1-} in
		( 1,*[!0123456789]* )
			die "isonterminal: invalid file descriptor: $1" ;;
		( 1,* )	[[ -t $1 ]] ;;
		( * )	_Msh_dieArgs isonterminal "$#" 1 ;;
		esac
	}
elif thisshellhas BUG_TESTILNUM; then
	# On dash, BUG_TESTILNUM causes test/[ to be misparsed once after
	# [ -t "$1" ] is called with an invalid number. As a workaround,
	# we need a dummy invocation of [ to restore correct parsing.
	isonterminal() {
		case ${#},${1-} in
		( 1,*[!0123456789]* )
			die "isonterminal: invalid file descriptor: $1" ;;
		( 1,* )	[ -t "$1" ]
			case $? in
			( 0 )	;;
			( 1 )	return 1 ;;
			( * )	[ 2 -gt 1 ] 2>/dev/null	# BUG_TESTILNUM workaround
				die "isonterminal: '[' failed" ;;
			esac ;;
		( * )	_Msh_dieArgs isonterminal "$#" 1 ;;
		esac
	}
else
	isonterminal() {
		case ${#},${1-} in
		( 1,*[!0123456789]* )
			die "isonterminal: invalid file descriptor: $1" ;;
		( 1,* )	[ -t "$1" ] || { let "$? > 1" && die "isonterminal: '[' failed"; } ;;
		( * )	_Msh_dieArgs isonterminal "$#" 1 ;;
		esac
	}
fi

# --- Two-argument file tests. ---
# (Note: the -nt, -ot and -ef test/[ operators are technically non-standard,
# but all modern POSIX-compliant shells support them in practice.)
if thisshellhas [[; then
	# Use [[ if available because it's generally faster and more robust;
	# this also avoids BUG_TESTRMPAR in zsh which makes it impossible
	# for test/[ to check a file with a name starting with '(' against a
	# file with a name starting with ')'.

	# Test if file 1 is newer than file 2.
	isnewer() {
		case $# in
		( 2 )	[[ $1 -nt $2 ]] ;;
		( * )	_Msh_dieArgs isnewerthan "$#" 2 ;;
		esac
	}

	# Test if file 1 is older than file 2.
	isolder() {
		case $# in
		( 2 )	[[ $1 -ot $2 ]] ;;
		( * )	_Msh_dieArgs isolderthan "$#" 2 ;;
		esac
	}

	# Test if file 1 and file 2 are the same file (hard links or symlinks).
	issamefile() {
		case $# in
		( 2 )	[[ $1 -ef $2 ]] ;;
		( * )	_Msh_dieArgs issamefileas "$#" 2 ;;
		esac
	}
else
	# Test if file 1 is newer than file 2.
	isnewer() {
		case $# in
		( 2 )	[ "$1" -nt "$2" ] || { let "$? > 1" && die "isnewerthan: '[' failed"; } ;;
		( * )	_Msh_dieArgs isnewerthan "$#" 2 ;;
		esac
	}

	# Test if file 1 is older than file 2.
	isolder() {
		case $# in
		( 2 )	[ "$1" -ot "$2" ] || { let "$? > 1" && die "isolderthan: '[' failed"; } ;;
		( * )	_Msh_dieArgs isolderthan "$#" 2 ;;
		esac
	}

	# Test if file 1 and file 2 are the same file (hard links or symlinks).
	issamefile() {
		case $# in
		( 2 )	[ "$1" -ef "$2" ] || { let "$? > 1" && die "issamefileas: '[' failed"; } ;;
		( * )	_Msh_dieArgs issamefileas "$#" 2 ;;
		esac
	}
fi

unset -v _Msh_PATH

# If shell supports it, then set modernish functions to read-only.
if thisshellhas ROFUNC; then
	readonly -f \
		builtin canread canwrite clearstack contains dec die div echo \
		ematch empty endswith eq exists extern ge gt harden identic inc \
		isint isnewer isnonempty isolder isonterminal issamefile isset \
		isvarname le let lt match mod mult ndiv ne pop poptrap print \
		printstack push pushtrap shellquote sig sortsafter sortsbefore \
		stackempty stacksize startswith thisshellhas unexport use \
		2>/dev/null
fi

# -------------------

# Initialization, phase 2.

# Restore 'allexport' option if it was set
if isset _Msh_allexport; then
	set -a
	unset -v _Msh_allexport
fi

# --------------------
# ------- MAIN -------
# --------------------

# Find out how modernish was invoked and launch the invoking program if necessary.
ME=$0	# temporary identity for possible error messages
if ! endswith "$0" '/modernish'; then
	# modernish was sourced
	case $- in
	( *i* )	unexport "ME=modernish on ${0#-}"
		printf "Welcome to the modernish age (version %s).\n" "$MSH_VERSION"
		if ! empty "$MSH_CAP"; then
			printf 'This shell has: %s\n' "$MSH_CAP"
		fi
		pushtrap 'printf "\nExiting modernish %s. Bye.\n" "$MSH_VERSION"' EXIT
		;;
	( * )	unexport "ME=$0"
		;;
	esac
	readonly ME
elif gt "$#" 0; then
	# modernish *is* the shell (e.g. '#!/usr/bin/env modernish'):
	# parse standard shell options.
	# TODO: make more consistent with other shells' option parsing.
	while match "${1:-}" '[+-]*'; do
		case $1 in
		( -c )
			ge "$#" 2 || _Msh_doExit 2 "option requires argument: -c"
			_Msh_cmd=$2
			shift 2
			eval "${_Msh_cmd}"
			exit
			;;
		( -i | -l )
			_Msh_doExit 2 "To use modernish interactively, source it ('. modernish') in your shell profile."
			;;
		( [+-]o )
			ge "$#" 2 || _Msh_doExit 2 "option requires argument: -o"
			command set "$1" "$2" || _Msh_doExit "$?" "'set $1 $2' failed"
			shift
			;;
		( [+-]* )
			command set "$1" || _Msh_doExit "$?" "'set $1' failed"
			;;
		( --version )
			printf '%s\n' "$MSH_VERSION"
			exit
			;;
		( -- )
			shift
			break
			;;
		( * )
			_Msh_doExit 2 "invalid option: $1"
			;;
		esac
		shift
	done
	unexport "ME=$1"
	readonly ME
	shift
	# We don't want '.' to search in $PATH instead of the current
	# directory; make sure it loads the file specified from the
	# current directory if no directory path was specified. (This
	# is consistent with other shells except bash, which searches
	# both in the current directory and in $PATH.)
	case $ME in
	( */* )	. "$ME" ;;
	( * )	. "./$ME" ;;
	esac
else
	_Msh_doExit 2 "To use modernish interactively, source it ('. modernish') in your shell profile."
fi
