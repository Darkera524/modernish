#!/bin/zsh
# modernish - a shell moderniser library that targets POSIX plus local variables.
# POSIX reference: http://pubs.opengroup.org/onlinepubs/9699919799/utilities/contents.html

# modernish system variables: $ME
# modernish internal global variable namespace: _msh_*

# TODO:
# - decide: set POSIXLY_CORRECT? make read-only?
# - decide how to deal with set -e; code is now not compatible with it
# - find out how to portably do test -o (for shell option checking)
#   so we can save the status of 'set -e' in catchfail
# - die(): more generic action for -u option
# - trawl for functionality: http://www.etalabs.net/sh_tricks.html


# Safe and portable 'echo' (if you want control chars, use printf instead)
echo() {
	if test "$1" = '-n'; then
		shift
		printf '%s' "$*"
	else
		printf '%s\n' "$*"
	fi
}

# Extended 'exit'. Usage: exitwith [ -u ] [ <status> [ <message> ] ]
# (We cannot overload 'exit' itself. ksh says: invalid function name)
exitwith() {
	exitstatus=$?
	unset -v opt_usage
	test "$1" = "-u" && opt_usage=y && shift
	exitstatus=$1
	shift
	test -n "$*" && printf '%s: %s\n' "${ME##*/}" "$*" 1>&2
	test -n "$opt_usage" && printf 'Type %s --help for help.\n' "${ME##*/}" 1>&2
	exit $exitstatus
}

# Exit gracefully on error, even from subshells. Usage: die [ -u ] [ <message> ]
die() {
	unset -v opt_usage
	test "$1" = "-u" && opt_usage=y && shift
	test -n "$*" && printf '%s: %s\n' "${ME##*/}" "$*" 1>&2
	test -n "$opt_usage" && printf 'Type %s --help for help.\n' "${ME##*/}" 1>&2
	mypid=$(exec sh -c 'printf "%u\n" $PPID') || exit $exitstatus
	test $mypid -ne $$ && kill $$  # if we're in a subshell, kill main process
	exit 143   # same exit status as produced by kill, for consistency
}

# Use a modernish module.
use() {
	test $# -gt 0 || die "use: needs module name"
	test -r "${_msh_ModulesDir}/$1" || die "use: module $1 not found"
	. "${_msh_ModulesDir}/$1" "$@"
}

# Check for success. Allows: if so; then <commands>; fi
so() {
	test $? -eq 0
}

# Check for non-success. Allows: if not; then <commands>; fi
not() {
	test $? -ne 0
}

# --- init ---

# Get the GNU to behave a little better.
export POSIXLY_CORRECT=y

# Beat zsh into compliance.
test -z "$ZSH_VERSION" || emulate sh

# Temporary identity.
ME=$(command -v modernish) || ME=modernish die "can't find myself"

# Test if this shell supports local variables. If not, provide a fake substitute.
# (As far as I know, this is only ksh93.)
testlocal() { local testvar=1 && test $testvar -eq 1; }
testlocal 2>/dev/null || die "this shell does not support local variables"

# Find the modules directory.
dir="${ME%/*}/../libexec/modernish"
readonly _msh_ModulesDir=$(cd "$dir" && pwd -P) || die "modules directory not found"
unset -v dir

# Find out how modernish was invoked and run the invoking program.
if test "${0##*/}" = 'modernish' && test $# -gt 0; then
	# modernish has been loaded with '#!/usr/bin/env modernish'
	readonly ME="$1"
	shift
	. "$ME" "$@"
else
	# modernish has been sourced
	readonly ME="$0"
fi
